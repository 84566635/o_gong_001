; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -obsp_key.o --depend=bsp_key.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\ARM\INC -ID:\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=bsp_key.crf user\src\bsp_key.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  IsKeyDown1 PROC
;;;90     
;;;91     	static uint8_t IsKeyDown1(void) {if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0) return 1;else return 0;}
000000  48b8              LDR      r0,|L1.740|
000002  6880              LDR      r0,[r0,#8]
000004  f0100f01          TST      r0,#1
000008  d101              BNE      |L1.14|
00000a  2001              MOVS     r0,#1
                  |L1.12|
00000c  4770              BX       lr
                  |L1.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L1.12|
;;;92     	static uint8_t IsKeyDown2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0) return 1;else return 0;}
                          ENDP

                  IsKeyDown2 PROC
000012  48b4              LDR      r0,|L1.740|
000014  6880              LDR      r0,[r0,#8]
000016  f0100f02          TST      r0,#2
00001a  d101              BNE      |L1.32|
00001c  2001              MOVS     r0,#1
                  |L1.30|
00001e  4770              BX       lr
                  |L1.32|
000020  2000              MOVS     r0,#0
000022  e7fc              B        |L1.30|
;;;93     	static uint8_t IsKeyDown3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0) return 1;else return 0;}
                          ENDP

                  IsKeyDown3 PROC
000024  48af              LDR      r0,|L1.740|
000026  6880              LDR      r0,[r0,#8]
000028  f0100f04          TST      r0,#4
00002c  d101              BNE      |L1.50|
00002e  2001              MOVS     r0,#1
                  |L1.48|
000030  4770              BX       lr
                  |L1.50|
000032  2000              MOVS     r0,#0
000034  e7fc              B        |L1.48|
;;;94     	static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
                          ENDP

                  IsKeyDown4 PROC
000036  48ab              LDR      r0,|L1.740|
000038  6880              LDR      r0,[r0,#8]
00003a  f0100f08          TST      r0,#8
00003e  d101              BNE      |L1.68|
000040  2001              MOVS     r0,#1
                  |L1.66|
000042  4770              BX       lr
                  |L1.68|
000044  2000              MOVS     r0,#0
000046  e7fc              B        |L1.66|
;;;95     	static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 0) return 1;else return 0;}
                          ENDP

                  IsKeyDown5 PROC
000048  48a6              LDR      r0,|L1.740|
00004a  6880              LDR      r0,[r0,#8]
00004c  f0100f10          TST      r0,#0x10
000050  d101              BNE      |L1.86|
000052  2001              MOVS     r0,#1
                  |L1.84|
000054  4770              BX       lr
                  |L1.86|
000056  2000              MOVS     r0,#0
000058  e7fc              B        |L1.84|
;;;96     	static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
                          ENDP

                  IsKeyDown6 PROC
00005a  48a2              LDR      r0,|L1.740|
00005c  6880              LDR      r0,[r0,#8]
00005e  f0100f20          TST      r0,#0x20
000062  d101              BNE      |L1.104|
000064  2001              MOVS     r0,#1
                  |L1.102|
000066  4770              BX       lr
                  |L1.104|
000068  2000              MOVS     r0,#0
00006a  e7fc              B        |L1.102|
;;;97     // 	static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
                          ENDP

                  bsp_InitKeyHard PROC
;;;242    */
;;;243    static void bsp_InitKeyHard(void)
00006c  b508              PUSH     {r3,lr}
;;;244    {
;;;245    	GPIO_InitTypeDef GPIO_InitStructure;
;;;246    
;;;247    	/* 第1步：打开GPIO时钟 */
;;;248    	RCC_APB2PeriphClockCmd(RCC_ALL_KEY, ENABLE);
00006e  2101              MOVS     r1,#1
000070  2010              MOVS     r0,#0x10
000072  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;249    
;;;250    	/* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;251    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;		/* 设为输入口 */
000076  2028              MOVS     r0,#0x28
000078  f88d0003          STRB     r0,[sp,#3]
;;;252    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
00007c  2003              MOVS     r0,#3
00007e  f88d0002          STRB     r0,[sp,#2]
;;;253    
;;;254    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K1;
000082  2001              MOVS     r0,#1
000084  f8ad0000          STRH     r0,[sp,#0]
;;;255    	GPIO_Init(GPIO_PORT_K1, &GPIO_InitStructure);
000088  4669              MOV      r1,sp
00008a  4896              LDR      r0,|L1.740|
00008c  f7fffffe          BL       GPIO_Init
;;;256    
;;;257    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K2;
000090  2002              MOVS     r0,#2
000092  f8ad0000          STRH     r0,[sp,#0]
;;;258    	GPIO_Init(GPIO_PORT_K2, &GPIO_InitStructure);
000096  4669              MOV      r1,sp
000098  4892              LDR      r0,|L1.740|
00009a  f7fffffe          BL       GPIO_Init
;;;259    
;;;260    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K3;
00009e  2004              MOVS     r0,#4
0000a0  f8ad0000          STRH     r0,[sp,#0]
;;;261    	GPIO_Init(GPIO_PORT_K3, &GPIO_InitStructure);
0000a4  4669              MOV      r1,sp
0000a6  488f              LDR      r0,|L1.740|
0000a8  f7fffffe          BL       GPIO_Init
;;;262    
;;;263    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K4;
0000ac  2008              MOVS     r0,#8
0000ae  f8ad0000          STRH     r0,[sp,#0]
;;;264    	GPIO_Init(GPIO_PORT_K4, &GPIO_InitStructure);
0000b2  4669              MOV      r1,sp
0000b4  488b              LDR      r0,|L1.740|
0000b6  f7fffffe          BL       GPIO_Init
;;;265    
;;;266    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K5;
0000ba  2010              MOVS     r0,#0x10
0000bc  f8ad0000          STRH     r0,[sp,#0]
;;;267    	GPIO_Init(GPIO_PORT_K5, &GPIO_InitStructure);
0000c0  4669              MOV      r1,sp
0000c2  4888              LDR      r0,|L1.740|
0000c4  f7fffffe          BL       GPIO_Init
;;;268    
;;;269     	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K6;
0000c8  2020              MOVS     r0,#0x20
0000ca  f8ad0000          STRH     r0,[sp,#0]
;;;270     	GPIO_Init(GPIO_PORT_K6, &GPIO_InitStructure);
0000ce  4669              MOV      r1,sp
0000d0  4884              LDR      r0,|L1.740|
0000d2  f7fffffe          BL       GPIO_Init
;;;271    
;;;272    // 	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K7;
;;;273    // 	GPIO_Init(GPIO_PORT_K7, &GPIO_InitStructure);
;;;274    
;;;275    // 	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K8;
;;;276    // 	GPIO_Init(GPIO_PORT_K8, &GPIO_InitStructure);
;;;277    }
0000d6  bd08              POP      {r3,pc}
;;;278    
                          ENDP

                  bsp_InitKeyVar PROC
;;;286    */
;;;287    static void bsp_InitKeyVar(void)
0000d8  2100              MOVS     r1,#0
;;;288    {
;;;289    	uint8_t i;
;;;290    
;;;291    	/* 对按键FIFO读写指针清零 */
;;;292    	s_tKey.Read = 0;
0000da  4a83              LDR      r2,|L1.744|
0000dc  7191              STRB     r1,[r2,#6]
;;;293    	s_tKey.Write = 0;
0000de  71d1              STRB     r1,[r2,#7]
;;;294    	s_tKey.Read2 = 0;
0000e0  7211              STRB     r1,[r2,#8]
;;;295    
;;;296    	/* 给每个按键结构体成员变量赋一组缺省值 */
;;;297    	for (i = 0; i < KEY_COUNT; i++)
0000e2  2000              MOVS     r0,#0
0000e4  e01d              B        |L1.290|
                  |L1.230|
;;;298    	{
;;;299    		s_tBtn[i].LongTime = KEY_LONG_TIME;			/* 长按时间 0 表示不检测长按键事件 */
0000e6  2164              MOVS     r1,#0x64
0000e8  4a7f              LDR      r2,|L1.744|
0000ea  3a60              SUBS     r2,r2,#0x60
0000ec  eb021200          ADD      r2,r2,r0,LSL #4
0000f0  8111              STRH     r1,[r2,#8]
;;;300    		s_tBtn[i].Count = KEY_FILTER_TIME / 2;		/* 计数器设置为滤波时间的一半 */
0000f2  2102              MOVS     r1,#2
0000f4  4a7c              LDR      r2,|L1.744|
0000f6  3a60              SUBS     r2,r2,#0x60
0000f8  eb021200          ADD      r2,r2,r0,LSL #4
0000fc  7111              STRB     r1,[r2,#4]
;;;301    		s_tBtn[i].State = 0;							/* 按键缺省状态，0为未按下 */
0000fe  2100              MOVS     r1,#0
000100  4a79              LDR      r2,|L1.744|
000102  3a60              SUBS     r2,r2,#0x60
000104  eb021200          ADD      r2,r2,r0,LSL #4
000108  7291              STRB     r1,[r2,#0xa]
;;;302    		//s_tBtn[i].KeyCodeDown = 3 * i + 1;				/* 按键按下的键值代码 */
;;;303    		//s_tBtn[i].KeyCodeUp   = 3 * i + 2;				/* 按键弹起的键值代码 */
;;;304    		//s_tBtn[i].KeyCodeLong = 3 * i + 3;				/* 按键被持续按下的键值代码 */
;;;305    		s_tBtn[i].RepeatSpeed = 0;						/* 按键连发的速度，0表示不支持连发 */
00010a  4a77              LDR      r2,|L1.744|
00010c  3a60              SUBS     r2,r2,#0x60
00010e  eb021200          ADD      r2,r2,r0,LSL #4
000112  72d1              STRB     r1,[r2,#0xb]
;;;306    		s_tBtn[i].RepeatCount = 0;						/* 连发计数器 */
000114  4a74              LDR      r2,|L1.744|
000116  3a60              SUBS     r2,r2,#0x60
000118  eb021200          ADD      r2,r2,r0,LSL #4
00011c  7311              STRB     r1,[r2,#0xc]
00011e  1c41              ADDS     r1,r0,#1              ;297
000120  b2c8              UXTB     r0,r1                 ;297
                  |L1.290|
000122  2806              CMP      r0,#6                 ;297
000124  dbdf              BLT      |L1.230|
;;;307    	}
;;;308    
;;;309    	/* 如果需要单独更改某个按键的参数，可以在此单独重新赋值 */
;;;310    	/* 比如，我们希望按键1按下超过1秒后，自动重发相同键值 */
;;;311    // 	s_tBtn[KID_JOY_U].LongTime = 100;
;;;312    // 	s_tBtn[KID_JOY_U].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
;;;313    
;;;314    // 	s_tBtn[KID_JOY_D].LongTime = 100;
;;;315    // 	s_tBtn[KID_JOY_D].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
;;;316    
;;;317    // 	s_tBtn[KID_JOY_L].LongTime = 100;
;;;318    // 	s_tBtn[KID_JOY_L].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
;;;319    
;;;320    // 	s_tBtn[KID_JOY_R].LongTime = 100;
;;;321    // 	s_tBtn[KID_JOY_R].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
;;;322    
;;;323    	/* 判断按键按下的函数 */
;;;324    	s_tBtn[0].IsKeyDownFunc = IsKeyDown1;
000126  4971              LDR      r1,|L1.748|
000128  4a6f              LDR      r2,|L1.744|
00012a  3a60              SUBS     r2,r2,#0x60
00012c  6011              STR      r1,[r2,#0]  ; s_tBtn
;;;325    	s_tBtn[1].IsKeyDownFunc = IsKeyDown2;
00012e  4970              LDR      r1,|L1.752|
000130  6111              STR      r1,[r2,#0x10]  ; s_tBtn
;;;326    	s_tBtn[2].IsKeyDownFunc = IsKeyDown3;
000132  4970              LDR      r1,|L1.756|
000134  6211              STR      r1,[r2,#0x20]  ; s_tBtn
;;;327    	s_tBtn[3].IsKeyDownFunc = IsKeyDown4;
000136  4970              LDR      r1,|L1.760|
000138  6311              STR      r1,[r2,#0x30]  ; s_tBtn
;;;328    	s_tBtn[4].IsKeyDownFunc = IsKeyDown5;
00013a  4970              LDR      r1,|L1.764|
00013c  6411              STR      r1,[r2,#0x40]  ; s_tBtn
;;;329    	s_tBtn[5].IsKeyDownFunc = IsKeyDown6;
00013e  4970              LDR      r1,|L1.768|
000140  6511              STR      r1,[r2,#0x50]  ; s_tBtn
;;;330    // 	s_tBtn[6].IsKeyDownFunc = IsKeyDown7;
;;;331    // 	s_tBtn[7].IsKeyDownFunc = IsKeyDown8;
;;;332    
;;;333    	/* 组合键 */
;;;334    // 	s_tBtn[8].IsKeyDownFunc = IsKeyDown9;
;;;335    // 	s_tBtn[9].IsKeyDownFunc = IsKeyDown10;
;;;336    }
000142  4770              BX       lr
;;;337    
                          ENDP

                  bsp_InitKey PROC
;;;110    */
;;;111    void bsp_InitKey(void)
000144  b510              PUSH     {r4,lr}
;;;112    {
;;;113    	bsp_InitKeyVar();		/* 初始化按键变量 */
000146  f7fffffe          BL       bsp_InitKeyVar
;;;114    	bsp_InitKeyHard();		/* 初始化按键硬件 */
00014a  f7fffffe          BL       bsp_InitKeyHard
;;;115    }
00014e  bd10              POP      {r4,pc}
;;;116    
                          ENDP

                  bsp_PutKey PROC
;;;124    */
;;;125    void bsp_PutKey(uint8_t _KeyCode)
000150  4965              LDR      r1,|L1.744|
;;;126    {
;;;127    	s_tKey.Buf[s_tKey.Write] = _KeyCode;
000152  79c9              LDRB     r1,[r1,#7]  ; s_tKey
000154  4a64              LDR      r2,|L1.744|
000156  5450              STRB     r0,[r2,r1]
;;;128    
;;;129    	if (++s_tKey.Write  >= KEY_FIFO_SIZE)
000158  4611              MOV      r1,r2
00015a  79c9              LDRB     r1,[r1,#7]  ; s_tKey
00015c  1c49              ADDS     r1,r1,#1
00015e  b2c9              UXTB     r1,r1
000160  71d1              STRB     r1,[r2,#7]
000162  2906              CMP      r1,#6
000164  db01              BLT      |L1.362|
;;;130    	{
;;;131    		s_tKey.Write = 0;
000166  2100              MOVS     r1,#0
000168  71d1              STRB     r1,[r2,#7]
                  |L1.362|
;;;132    	}
;;;133    }
00016a  4770              BX       lr
;;;134    
                          ENDP

                  bsp_GetKey PROC
;;;142    */
;;;143    uint8_t bsp_GetKey(void)
00016c  485e              LDR      r0,|L1.744|
;;;144    {
;;;145    	uint8_t ret;
;;;146    
;;;147    	if (s_tKey.Read == s_tKey.Write)
00016e  7980              LDRB     r0,[r0,#6]  ; s_tKey
000170  4a5d              LDR      r2,|L1.744|
000172  79d2              LDRB     r2,[r2,#7]  ; s_tKey
000174  4290              CMP      r0,r2
000176  d101              BNE      |L1.380|
;;;148    	{
;;;149    		return KEY_NONE;
000178  2000              MOVS     r0,#0
                  |L1.378|
;;;150    	}
;;;151    	else
;;;152    	{
;;;153    		ret = s_tKey.Buf[s_tKey.Read];
;;;154    
;;;155    		if (++s_tKey.Read >= KEY_FIFO_SIZE)
;;;156    		{
;;;157    			s_tKey.Read = 0;
;;;158    		}
;;;159    		return ret;
;;;160    	}
;;;161    }
00017a  4770              BX       lr
                  |L1.380|
00017c  485a              LDR      r0,|L1.744|
00017e  7980              LDRB     r0,[r0,#6]            ;153  ; s_tKey
000180  4a59              LDR      r2,|L1.744|
000182  5c11              LDRB     r1,[r2,r0]            ;153
000184  4610              MOV      r0,r2                 ;155
000186  7980              LDRB     r0,[r0,#6]            ;155  ; s_tKey
000188  1c40              ADDS     r0,r0,#1              ;155
00018a  b2c0              UXTB     r0,r0                 ;155
00018c  7190              STRB     r0,[r2,#6]            ;155
00018e  2806              CMP      r0,#6                 ;155
000190  db01              BLT      |L1.406|
000192  2000              MOVS     r0,#0                 ;157
000194  7190              STRB     r0,[r2,#6]            ;157
                  |L1.406|
000196  4608              MOV      r0,r1                 ;159
000198  e7ef              B        |L1.378|
;;;162    
                          ENDP

                  bsp_GetKey2 PROC
;;;170    */
;;;171    uint8_t bsp_GetKey2(void)
00019a  4853              LDR      r0,|L1.744|
;;;172    {
;;;173    	uint8_t ret;
;;;174    
;;;175    	if (s_tKey.Read2 == s_tKey.Write)
00019c  7a00              LDRB     r0,[r0,#8]  ; s_tKey
00019e  4a52              LDR      r2,|L1.744|
0001a0  79d2              LDRB     r2,[r2,#7]  ; s_tKey
0001a2  4290              CMP      r0,r2
0001a4  d101              BNE      |L1.426|
;;;176    	{
;;;177    		return KEY_NONE;
0001a6  2000              MOVS     r0,#0
                  |L1.424|
;;;178    	}
;;;179    	else
;;;180    	{
;;;181    		ret = s_tKey.Buf[s_tKey.Read2];
;;;182    
;;;183    		if (++s_tKey.Read2 >= KEY_FIFO_SIZE)
;;;184    		{
;;;185    			s_tKey.Read2 = 0;
;;;186    		}
;;;187    		return ret;
;;;188    	}
;;;189    }
0001a8  4770              BX       lr
                  |L1.426|
0001aa  484f              LDR      r0,|L1.744|
0001ac  7a00              LDRB     r0,[r0,#8]            ;181  ; s_tKey
0001ae  4a4e              LDR      r2,|L1.744|
0001b0  5c11              LDRB     r1,[r2,r0]            ;181
0001b2  4610              MOV      r0,r2                 ;183
0001b4  7a00              LDRB     r0,[r0,#8]            ;183  ; s_tKey
0001b6  1c40              ADDS     r0,r0,#1              ;183
0001b8  b2c0              UXTB     r0,r0                 ;183
0001ba  7210              STRB     r0,[r2,#8]            ;183
0001bc  2806              CMP      r0,#6                 ;183
0001be  db01              BLT      |L1.452|
0001c0  2000              MOVS     r0,#0                 ;185
0001c2  7210              STRB     r0,[r2,#8]            ;185
                  |L1.452|
0001c4  4608              MOV      r0,r1                 ;187
0001c6  e7ef              B        |L1.424|
;;;190    
                          ENDP

                  bsp_GetKeyState PROC
;;;198    */
;;;199    uint8_t bsp_GetKeyState(KEY_ID_E _ucKeyID)
0001c8  4601              MOV      r1,r0
;;;200    {
;;;201    	return s_tBtn[_ucKeyID].State;
0001ca  4847              LDR      r0,|L1.744|
0001cc  3860              SUBS     r0,r0,#0x60
0001ce  eb001001          ADD      r0,r0,r1,LSL #4
0001d2  7a80              LDRB     r0,[r0,#0xa]
;;;202    }
0001d4  4770              BX       lr
;;;203    
                          ENDP

                  bsp_SetKeyParam PROC
;;;213    */
;;;214    void bsp_SetKeyParam(uint8_t _ucKeyID, uint16_t _LongTime, uint8_t  _RepeatSpeed)
0001d6  b510              PUSH     {r4,lr}
;;;215    {
;;;216    	s_tBtn[_ucKeyID].LongTime = _LongTime;			/* 长按时间 0 表示不检测长按键事件 */
0001d8  4b43              LDR      r3,|L1.744|
0001da  3b60              SUBS     r3,r3,#0x60
0001dc  eb031300          ADD      r3,r3,r0,LSL #4
0001e0  8119              STRH     r1,[r3,#8]
;;;217    	s_tBtn[_ucKeyID].RepeatSpeed = _RepeatSpeed;			/* 按键连发的速度，0表示不支持连发 */
0001e2  4b41              LDR      r3,|L1.744|
0001e4  3b60              SUBS     r3,r3,#0x60
0001e6  eb031300          ADD      r3,r3,r0,LSL #4
0001ea  72da              STRB     r2,[r3,#0xb]
;;;218    	s_tBtn[_ucKeyID].RepeatCount = 0;						/* 连发计数器 */
0001ec  2300              MOVS     r3,#0
0001ee  4c3e              LDR      r4,|L1.744|
0001f0  3c60              SUBS     r4,r4,#0x60
0001f2  eb041400          ADD      r4,r4,r0,LSL #4
0001f6  7323              STRB     r3,[r4,#0xc]
;;;219    }
0001f8  bd10              POP      {r4,pc}
;;;220    
                          ENDP

                  bsp_ClearKey PROC
;;;229    */
;;;230    void bsp_ClearKey(void)
0001fa  483b              LDR      r0,|L1.744|
;;;231    {
;;;232    	s_tKey.Read = s_tKey.Write;
0001fc  79c0              LDRB     r0,[r0,#7]  ; s_tKey
0001fe  493a              LDR      r1,|L1.744|
000200  7188              STRB     r0,[r1,#6]
;;;233    }
000202  4770              BX       lr
;;;234    
                          ENDP

                  bsp_DetectKey PROC
;;;345    */
;;;346    static void bsp_DetectKey(uint8_t i)
000204  b570              PUSH     {r4-r6,lr}
;;;347    {
000206  4604              MOV      r4,r0
;;;348    	KEY_T *pBtn;
;;;349    
;;;350    	/*
;;;351    		如果没有初始化按键函数，则报错
;;;352    		if (s_tBtn[i].IsKeyDownFunc == 0)
;;;353    		{
;;;354    			printf("Fault : DetectButton(), s_tBtn[i].IsKeyDownFunc undefine");
;;;355    		}
;;;356    	*/
;;;357    
;;;358    	pBtn = &s_tBtn[i];
000208  4837              LDR      r0,|L1.744|
00020a  3860              SUBS     r0,r0,#0x60
00020c  eb001504          ADD      r5,r0,r4,LSL #4
;;;359    	if (pBtn->IsKeyDownFunc())
000210  6828              LDR      r0,[r5,#0]
000212  4780              BLX      r0
000214  2800              CMP      r0,#0
000216  d03e              BEQ      |L1.662|
;;;360    	{
;;;361    		if (pBtn->Count < KEY_FILTER_TIME)
000218  7928              LDRB     r0,[r5,#4]
00021a  2805              CMP      r0,#5
00021c  da02              BGE      |L1.548|
;;;362    		{
;;;363    			pBtn->Count = KEY_FILTER_TIME;
00021e  2005              MOVS     r0,#5
000220  7128              STRB     r0,[r5,#4]
000222  e052              B        |L1.714|
                  |L1.548|
;;;364    		}
;;;365    		else if(pBtn->Count < 2 * KEY_FILTER_TIME)
000224  7928              LDRB     r0,[r5,#4]
000226  280a              CMP      r0,#0xa
000228  da03              BGE      |L1.562|
;;;366    		{
;;;367    			pBtn->Count++;
00022a  7928              LDRB     r0,[r5,#4]
00022c  1c40              ADDS     r0,r0,#1
00022e  7128              STRB     r0,[r5,#4]
000230  e04b              B        |L1.714|
                  |L1.562|
;;;368    		}
;;;369    		else
;;;370    		{
;;;371    			if (pBtn->State == 0)
000232  7aa8              LDRB     r0,[r5,#0xa]
000234  b938              CBNZ     r0,|L1.582|
;;;372    			{
;;;373    				pBtn->State = 1;
000236  2001              MOVS     r0,#1
000238  72a8              STRB     r0,[r5,#0xa]
;;;374    
;;;375    				/* 发送按钮按下的消息 */
;;;376    				bsp_PutKey((uint8_t)(3 * i + 1));
00023a  eb040144          ADD      r1,r4,r4,LSL #1
00023e  1c49              ADDS     r1,r1,#1
000240  b2c8              UXTB     r0,r1
000242  f7fffffe          BL       bsp_PutKey
                  |L1.582|
;;;377    			}
;;;378    
;;;379    			if (pBtn->LongTime > 0)
000246  8928              LDRH     r0,[r5,#8]
000248  2800              CMP      r0,#0
00024a  dd3e              BLE      |L1.714|
;;;380    			{
;;;381    				if (pBtn->LongCount < pBtn->LongTime)
00024c  88e8              LDRH     r0,[r5,#6]
00024e  8929              LDRH     r1,[r5,#8]
000250  4288              CMP      r0,r1
000252  da0d              BGE      |L1.624|
;;;382    				{
;;;383    					/* 发送按钮持续按下的消息 */
;;;384    					if (++pBtn->LongCount == pBtn->LongTime)
000254  88e8              LDRH     r0,[r5,#6]
000256  1c40              ADDS     r0,r0,#1
000258  b280              UXTH     r0,r0
00025a  80e8              STRH     r0,[r5,#6]
00025c  8929              LDRH     r1,[r5,#8]
00025e  4288              CMP      r0,r1
000260  d133              BNE      |L1.714|
;;;385    					{
;;;386    						/* 键值放入按键FIFO */
;;;387    						bsp_PutKey((uint8_t)(3 * i + 3));
000262  eb040144          ADD      r1,r4,r4,LSL #1
000266  1cc9              ADDS     r1,r1,#3
000268  b2c8              UXTB     r0,r1
00026a  f7fffffe          BL       bsp_PutKey
00026e  e02c              B        |L1.714|
                  |L1.624|
;;;388    					}
;;;389    				}
;;;390    				else
;;;391    				{
;;;392    					if (pBtn->RepeatSpeed > 0)
000270  7ae8              LDRB     r0,[r5,#0xb]
000272  2800              CMP      r0,#0
000274  dd29              BLE      |L1.714|
;;;393    					{
;;;394    						if (++pBtn->RepeatCount >= pBtn->RepeatSpeed)
000276  7b28              LDRB     r0,[r5,#0xc]
000278  1c40              ADDS     r0,r0,#1
00027a  b2c0              UXTB     r0,r0
00027c  7328              STRB     r0,[r5,#0xc]
00027e  7ae9              LDRB     r1,[r5,#0xb]
000280  4288              CMP      r0,r1
000282  db22              BLT      |L1.714|
;;;395    						{
;;;396    							pBtn->RepeatCount = 0;
000284  2000              MOVS     r0,#0
000286  7328              STRB     r0,[r5,#0xc]
;;;397    							/* 常按键后，每隔10ms发送1个按键 */
;;;398    							bsp_PutKey((uint8_t)(3 * i + 1));
000288  eb040144          ADD      r1,r4,r4,LSL #1
00028c  1c49              ADDS     r1,r1,#1
00028e  b2c8              UXTB     r0,r1
000290  f7fffffe          BL       bsp_PutKey
000294  e019              B        |L1.714|
                  |L1.662|
;;;399    						}
;;;400    					}
;;;401    				}
;;;402    			}
;;;403    		}
;;;404    	}
;;;405    	else
;;;406    	{
;;;407    		if(pBtn->Count > KEY_FILTER_TIME)
000296  7928              LDRB     r0,[r5,#4]
000298  2805              CMP      r0,#5
00029a  dd02              BLE      |L1.674|
;;;408    		{
;;;409    			pBtn->Count = KEY_FILTER_TIME;
00029c  2005              MOVS     r0,#5
00029e  7128              STRB     r0,[r5,#4]
0002a0  e010              B        |L1.708|
                  |L1.674|
;;;410    		}
;;;411    		else if(pBtn->Count != 0)
0002a2  7928              LDRB     r0,[r5,#4]
0002a4  b118              CBZ      r0,|L1.686|
;;;412    		{
;;;413    			pBtn->Count--;
0002a6  7928              LDRB     r0,[r5,#4]
0002a8  1e40              SUBS     r0,r0,#1
0002aa  7128              STRB     r0,[r5,#4]
0002ac  e00a              B        |L1.708|
                  |L1.686|
;;;414    		}
;;;415    		else
;;;416    		{
;;;417    			if (pBtn->State == 1)
0002ae  7aa8              LDRB     r0,[r5,#0xa]
0002b0  2801              CMP      r0,#1
0002b2  d107              BNE      |L1.708|
;;;418    			{
;;;419    				pBtn->State = 0;
0002b4  2000              MOVS     r0,#0
0002b6  72a8              STRB     r0,[r5,#0xa]
;;;420    
;;;421    				/* 发送按钮弹起的消息 */
;;;422    				bsp_PutKey((uint8_t)(3 * i + 2));
0002b8  eb040144          ADD      r1,r4,r4,LSL #1
0002bc  1c89              ADDS     r1,r1,#2
0002be  b2c8              UXTB     r0,r1
0002c0  f7fffffe          BL       bsp_PutKey
                  |L1.708|
;;;423    			}
;;;424    		}
;;;425    
;;;426    		pBtn->LongCount = 0;
0002c4  2000              MOVS     r0,#0
0002c6  80e8              STRH     r0,[r5,#6]
;;;427    		pBtn->RepeatCount = 0;
0002c8  7328              STRB     r0,[r5,#0xc]
                  |L1.714|
;;;428    	}
;;;429    }
0002ca  bd70              POP      {r4-r6,pc}
;;;430    
                          ENDP

                  bsp_KeyScan PROC
;;;438    */
;;;439    void bsp_KeyScan(void)
0002cc  b510              PUSH     {r4,lr}
;;;440    {
;;;441    	uint8_t i;
;;;442    
;;;443    	for (i = 0; i < KEY_COUNT; i++)
0002ce  2400              MOVS     r4,#0
0002d0  e004              B        |L1.732|
                  |L1.722|
;;;444    	{
;;;445    		bsp_DetectKey(i);
0002d2  4620              MOV      r0,r4
0002d4  f7fffffe          BL       bsp_DetectKey
0002d8  1c60              ADDS     r0,r4,#1              ;443
0002da  b2c4              UXTB     r4,r0                 ;443
                  |L1.732|
0002dc  2c06              CMP      r4,#6                 ;443
0002de  dbf8              BLT      |L1.722|
;;;446    	}
;;;447    }
0002e0  bd10              POP      {r4,pc}
;;;448    
                          ENDP

0002e2  0000              DCW      0x0000
                  |L1.740|
                          DCD      0x40011000
                  |L1.744|
                          DCD      ||.bss||+0x60
                  |L1.748|
                          DCD      IsKeyDown1
                  |L1.752|
                          DCD      IsKeyDown2
                  |L1.756|
                          DCD      IsKeyDown3
                  |L1.760|
                          DCD      IsKeyDown4
                  |L1.764|
                          DCD      IsKeyDown5
                  |L1.768|
                          DCD      IsKeyDown6

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tBtn
                          %        96
                  s_tKey
                          %        9
