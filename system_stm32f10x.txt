; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -osystem_stm32f10x.o --depend=system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\ARM\INC -ID:\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=system_stm32f10x.crf cmsis\system_stm32f10x.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;211      */
;;;212    void SystemInit (void)
000000  4866              LDR      r0,|L1.412|
;;;213    {
;;;214      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;215      /* Set HSION bit */
;;;216      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4964              LDR      r1,|L1.412|
00000a  6008              STR      r0,[r1,#0]
;;;217    
;;;218      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;219    #ifndef STM32F10X_CL
;;;220      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  4963              LDR      r1,|L1.416|
000012  4008              ANDS     r0,r0,r1
000014  4961              LDR      r1,|L1.412|
000016  6048              STR      r0,[r1,#4]
;;;221    #else
;;;222      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;223    #endif /* STM32F10X_CL */   
;;;224      
;;;225      /* Reset HSEON, CSSON and PLLON bits */
;;;226      RCC->CR &= (uint32_t)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  4961              LDR      r1,|L1.420|
00001e  4008              ANDS     r0,r0,r1
000020  495e              LDR      r1,|L1.412|
000022  6008              STR      r0,[r1,#0]
;;;227    
;;;228      /* Reset HSEBYP bit */
;;;229      RCC->CR &= (uint32_t)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f4202080          BIC      r0,r0,#0x40000
00002c  6008              STR      r0,[r1,#0]
;;;230    
;;;231      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;232      RCC->CFGR &= (uint32_t)0xFF80FFFF;
00002e  4608              MOV      r0,r1
000030  6840              LDR      r0,[r0,#4]
000032  f42000fe          BIC      r0,r0,#0x7f0000
000036  6048              STR      r0,[r1,#4]
;;;233    
;;;234    #ifdef STM32F10X_CL
;;;235      /* Reset PLL2ON and PLL3ON bits */
;;;236      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;237    
;;;238      /* Disable all interrupts and clear pending bits  */
;;;239      RCC->CIR = 0x00FF0000;
;;;240    
;;;241      /* Reset CFGR2 register */
;;;242      RCC->CFGR2 = 0x00000000;
;;;243    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;244      /* Disable all interrupts and clear pending bits  */
;;;245      RCC->CIR = 0x009F0000;
;;;246    
;;;247      /* Reset CFGR2 register */
;;;248      RCC->CFGR2 = 0x00000000;      
;;;249    #else
;;;250      /* Disable all interrupts and clear pending bits  */
;;;251      RCC->CIR = 0x009F0000;
000038  f44f001f          MOV      r0,#0x9f0000
00003c  6088              STR      r0,[r1,#8]
;;;252    #endif /* STM32F10X_CL */
;;;253        
;;;254    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;255      #ifdef DATA_IN_ExtSRAM
;;;256        SystemInit_ExtMemCtl(); 
;;;257      #endif /* DATA_IN_ExtSRAM */
;;;258    #endif 
;;;259    
;;;260      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;261      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;262    	
;;;263    	
;;;264      //SetSysClock();//这一个注释掉在外面用函数配置。//这里要注意呀
;;;265    
;;;266    #ifdef VECT_TAB_SRAM
;;;267      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;268    #else
;;;269      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
00003e  03c8              LSLS     r0,r1,#15
000040  4959              LDR      r1,|L1.424|
000042  6008              STR      r0,[r1,#0]
;;;270    #endif 
;;;271    }
000044  4770              BX       lr
;;;272    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;307      */
;;;308    void SystemCoreClockUpdate (void)
000046  b510              PUSH     {r4,lr}
;;;309    {
;;;310      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
000048  2000              MOVS     r0,#0
00004a  2100              MOVS     r1,#0
00004c  2200              MOVS     r2,#0
;;;311    
;;;312    #ifdef  STM32F10X_CL
;;;313      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;314    #endif /* STM32F10X_CL */
;;;315    
;;;316    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;317      uint32_t prediv1factor = 0;
;;;318    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;319        
;;;320      /* Get SYSCLK source -------------------------------------------------------*/
;;;321      tmp = RCC->CFGR & RCC_CFGR_SWS;
00004e  4b53              LDR      r3,|L1.412|
000050  685b              LDR      r3,[r3,#4]
000052  f003000c          AND      r0,r3,#0xc
;;;322      
;;;323      switch (tmp)
000056  b120              CBZ      r0,|L1.98|
000058  2804              CMP      r0,#4
00005a  d006              BEQ      |L1.106|
00005c  2808              CMP      r0,#8
00005e  d128              BNE      |L1.178|
000060  e007              B        |L1.114|
                  |L1.98|
;;;324      {
;;;325        case 0x00:  /* HSI used as system clock */
;;;326          SystemCoreClock = HSI_VALUE;
000062  4b52              LDR      r3,|L1.428|
000064  4c52              LDR      r4,|L1.432|
000066  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;327          break;
000068  e027              B        |L1.186|
                  |L1.106|
;;;328        case 0x04:  /* HSE used as system clock */
;;;329          SystemCoreClock = HSE_VALUE;
00006a  4b52              LDR      r3,|L1.436|
00006c  4c50              LDR      r4,|L1.432|
00006e  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;330          break;
000070  e023              B        |L1.186|
                  |L1.114|
;;;331        case 0x08:  /* PLL used as system clock */
;;;332    
;;;333          /* Get PLL clock source and multiplication factor ----------------------*/
;;;334          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
000072  4b4a              LDR      r3,|L1.412|
000074  685b              LDR      r3,[r3,#4]
000076  f4031170          AND      r1,r3,#0x3c0000
;;;335          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
00007a  4b48              LDR      r3,|L1.412|
00007c  685b              LDR      r3,[r3,#4]
00007e  f4033280          AND      r2,r3,#0x10000
;;;336          
;;;337    #ifndef STM32F10X_CL      
;;;338          pllmull = ( pllmull >> 18) + 2;
000082  2302              MOVS     r3,#2
000084  eb034191          ADD      r1,r3,r1,LSR #18
;;;339          
;;;340          if (pllsource == 0x00)
000088  b922              CBNZ     r2,|L1.148|
;;;341          {
;;;342            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;343            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
00008a  4b4b              LDR      r3,|L1.440|
00008c  434b              MULS     r3,r1,r3
00008e  4c48              LDR      r4,|L1.432|
000090  6023              STR      r3,[r4,#0]  ; SystemCoreClock
000092  e00d              B        |L1.176|
                  |L1.148|
;;;344          }
;;;345          else
;;;346          {
;;;347     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;348           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;349           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;350           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;351     #else
;;;352            /* HSE selected as PLL clock entry */
;;;353            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
000094  4b41              LDR      r3,|L1.412|
000096  685b              LDR      r3,[r3,#4]
000098  f4133f00          TST      r3,#0x20000
00009c  d004              BEQ      |L1.168|
;;;354            {/* HSE oscillator clock divided by 2 */
;;;355              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
00009e  4b47              LDR      r3,|L1.444|
0000a0  434b              MULS     r3,r1,r3
0000a2  4c43              LDR      r4,|L1.432|
0000a4  6023              STR      r3,[r4,#0]  ; SystemCoreClock
0000a6  e003              B        |L1.176|
                  |L1.168|
;;;356            }
;;;357            else
;;;358            {
;;;359              SystemCoreClock = HSE_VALUE * pllmull;
0000a8  4b42              LDR      r3,|L1.436|
0000aa  434b              MULS     r3,r1,r3
0000ac  4c40              LDR      r4,|L1.432|
0000ae  6023              STR      r3,[r4,#0]  ; SystemCoreClock
                  |L1.176|
;;;360            }
;;;361     #endif
;;;362          }
;;;363    #else
;;;364          pllmull = pllmull >> 18;
;;;365          
;;;366          if (pllmull != 0x0D)
;;;367          {
;;;368             pllmull += 2;
;;;369          }
;;;370          else
;;;371          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;372            pllmull = 13 / 2; 
;;;373          }
;;;374                
;;;375          if (pllsource == 0x00)
;;;376          {
;;;377            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;378            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;379          }
;;;380          else
;;;381          {/* PREDIV1 selected as PLL clock entry */
;;;382            
;;;383            /* Get PREDIV1 clock source and division factor */
;;;384            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;385            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;386            
;;;387            if (prediv1source == 0)
;;;388            { 
;;;389              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;390              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;391            }
;;;392            else
;;;393            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;394              
;;;395              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;396              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;397              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;398              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;399            }
;;;400          }
;;;401    #endif /* STM32F10X_CL */ 
;;;402          break;
0000b0  e003              B        |L1.186|
                  |L1.178|
;;;403    
;;;404        default:
;;;405          SystemCoreClock = HSI_VALUE;
0000b2  4b3e              LDR      r3,|L1.428|
0000b4  4c3e              LDR      r4,|L1.432|
0000b6  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;406          break;
0000b8  bf00              NOP      
                  |L1.186|
0000ba  bf00              NOP                            ;327
;;;407      }
;;;408      
;;;409      /* Compute HCLK clock frequency ----------------*/
;;;410      /* Get HCLK prescaler */
;;;411      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
0000bc  4b37              LDR      r3,|L1.412|
0000be  685b              LDR      r3,[r3,#4]
0000c0  f3c31303          UBFX     r3,r3,#4,#4
0000c4  4c3e              LDR      r4,|L1.448|
0000c6  5ce0              LDRB     r0,[r4,r3]
;;;412      /* HCLK clock frequency */
;;;413      SystemCoreClock >>= tmp;  
0000c8  4b39              LDR      r3,|L1.432|
0000ca  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
0000cc  40c3              LSRS     r3,r3,r0
0000ce  4c38              LDR      r4,|L1.432|
0000d0  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;414    }
0000d2  bd10              POP      {r4,pc}
;;;415    
                          ENDP

                  SetSysClockTo72 PROC
;;;988      */
;;;989    static void SetSysClockTo72(void)
0000d4  2000              MOVS     r0,#0
;;;990    {
;;;991      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
0000d6  2100              MOVS     r1,#0
;;;992      
;;;993      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;994      /* Enable HSE */    
;;;995      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
0000d8  4a30              LDR      r2,|L1.412|
0000da  6812              LDR      r2,[r2,#0]
0000dc  f4423280          ORR      r2,r2,#0x10000
0000e0  4b2e              LDR      r3,|L1.412|
0000e2  601a              STR      r2,[r3,#0]
;;;996     
;;;997      /* Wait till HSE is ready and if Time out is reached exit */
;;;998      do
0000e4  bf00              NOP      
                  |L1.230|
;;;999      {
;;;1000       HSEStatus = RCC->CR & RCC_CR_HSERDY;
0000e6  4a2d              LDR      r2,|L1.412|
0000e8  6812              LDR      r2,[r2,#0]
0000ea  f4023100          AND      r1,r2,#0x20000
;;;1001       StartUpCounter++;  
0000ee  1c40              ADDS     r0,r0,#1
;;;1002     } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
0000f0  b911              CBNZ     r1,|L1.248|
0000f2  f5b06fa0          CMP      r0,#0x500
0000f6  d1f6              BNE      |L1.230|
                  |L1.248|
;;;1003   
;;;1004     if ((RCC->CR & RCC_CR_HSERDY) != RESET)
0000f8  4a28              LDR      r2,|L1.412|
0000fa  6812              LDR      r2,[r2,#0]
0000fc  f4123f00          TST      r2,#0x20000
000100  d001              BEQ      |L1.262|
;;;1005     {
;;;1006       HSEStatus = (uint32_t)0x01;
000102  2101              MOVS     r1,#1
000104  e000              B        |L1.264|
                  |L1.262|
;;;1007     }
;;;1008     else
;;;1009     {
;;;1010       HSEStatus = (uint32_t)0x00;
000106  2100              MOVS     r1,#0
                  |L1.264|
;;;1011     }  
;;;1012   
;;;1013     if (HSEStatus == (uint32_t)0x01)
000108  2901              CMP      r1,#1
00010a  d142              BNE      |L1.402|
;;;1014     {
;;;1015       /* Enable Prefetch Buffer */
;;;1016       FLASH->ACR |= FLASH_ACR_PRFTBE;
00010c  4a2d              LDR      r2,|L1.452|
00010e  6812              LDR      r2,[r2,#0]
000110  f0420210          ORR      r2,r2,#0x10
000114  4b2b              LDR      r3,|L1.452|
000116  601a              STR      r2,[r3,#0]
;;;1017   
;;;1018       /* Flash 2 wait state */
;;;1019       FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000118  461a              MOV      r2,r3
00011a  6812              LDR      r2,[r2,#0]
00011c  f0220203          BIC      r2,r2,#3
000120  601a              STR      r2,[r3,#0]
;;;1020       FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000122  461a              MOV      r2,r3
000124  6812              LDR      r2,[r2,#0]
000126  f0420202          ORR      r2,r2,#2
00012a  601a              STR      r2,[r3,#0]
;;;1021   
;;;1022    
;;;1023       /* HCLK = SYSCLK */
;;;1024       RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
00012c  4a1b              LDR      r2,|L1.412|
00012e  6852              LDR      r2,[r2,#4]
000130  4b1a              LDR      r3,|L1.412|
000132  605a              STR      r2,[r3,#4]
;;;1025         
;;;1026       /* PCLK2 = HCLK */
;;;1027       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000134  461a              MOV      r2,r3
000136  6852              LDR      r2,[r2,#4]
000138  605a              STR      r2,[r3,#4]
;;;1028       
;;;1029       /* PCLK1 = HCLK */
;;;1030       RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
00013a  461a              MOV      r2,r3
00013c  6852              LDR      r2,[r2,#4]
00013e  f4426280          ORR      r2,r2,#0x400
000142  605a              STR      r2,[r3,#4]
;;;1031   
;;;1032   #ifdef STM32F10X_CL
;;;1033       /* Configure PLLs ------------------------------------------------------*/
;;;1034       /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;1035       /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;1036           
;;;1037       RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;1038                                 RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;1039       RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;1040                                RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;1041     
;;;1042       /* Enable PLL2 */
;;;1043       RCC->CR |= RCC_CR_PLL2ON;
;;;1044       /* Wait till PLL2 is ready */
;;;1045       while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;1046       {
;;;1047       }
;;;1048       
;;;1049      
;;;1050       /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;1051       RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;1052       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;1053                               RCC_CFGR_PLLMULL9); 
;;;1054   #else    
;;;1055       /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;1056       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000144  461a              MOV      r2,r3
000146  6852              LDR      r2,[r2,#4]
000148  f422127c          BIC      r2,r2,#0x3f0000
00014c  605a              STR      r2,[r3,#4]
;;;1057                                           RCC_CFGR_PLLMULL));
;;;1058       RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
00014e  461a              MOV      r2,r3
000150  6852              LDR      r2,[r2,#4]
000152  f44212e8          ORR      r2,r2,#0x1d0000
000156  605a              STR      r2,[r3,#4]
;;;1059   #endif /* STM32F10X_CL */
;;;1060   
;;;1061       /* Enable PLL */
;;;1062       RCC->CR |= RCC_CR_PLLON;
000158  461a              MOV      r2,r3
00015a  6812              LDR      r2,[r2,#0]
00015c  f0427280          ORR      r2,r2,#0x1000000
000160  601a              STR      r2,[r3,#0]
;;;1063   
;;;1064       /* Wait till PLL is ready */
;;;1065       while((RCC->CR & RCC_CR_PLLRDY) == 0)
000162  bf00              NOP      
                  |L1.356|
000164  4a0d              LDR      r2,|L1.412|
000166  6812              LDR      r2,[r2,#0]
000168  f0127f00          TST      r2,#0x2000000
00016c  d0fa              BEQ      |L1.356|
;;;1066       {
;;;1067       }
;;;1068       
;;;1069       /* Select PLL as system clock source */
;;;1070       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
00016e  4a0b              LDR      r2,|L1.412|
000170  6852              LDR      r2,[r2,#4]
000172  f0220203          BIC      r2,r2,#3
000176  4b09              LDR      r3,|L1.412|
000178  605a              STR      r2,[r3,#4]
;;;1071       RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
00017a  461a              MOV      r2,r3
00017c  6852              LDR      r2,[r2,#4]
00017e  f0420202          ORR      r2,r2,#2
000182  605a              STR      r2,[r3,#4]
;;;1072   
;;;1073       /* Wait till PLL is used as system clock source */
;;;1074       while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
000184  bf00              NOP      
                  |L1.390|
000186  4a05              LDR      r2,|L1.412|
000188  6852              LDR      r2,[r2,#4]
00018a  f002020c          AND      r2,r2,#0xc
00018e  2a08              CMP      r2,#8
000190  d1f9              BNE      |L1.390|
                  |L1.402|
;;;1075       {
;;;1076       }
;;;1077     }
;;;1078     else
;;;1079     { /* If HSE fails to start-up, the application will have wrong clock 
;;;1080            configuration. User can add here some code to deal with this error */
;;;1081     }
;;;1082   }
000192  4770              BX       lr
;;;1083   #endif
                          ENDP

                  SetSysClock PROC
;;;420      */
;;;421    static void SetSysClock(void)
000194  b510              PUSH     {r4,lr}
;;;422    {
;;;423    #ifdef SYSCLK_FREQ_HSE
;;;424      SetSysClockToHSE();
;;;425    #elif defined SYSCLK_FREQ_24MHz
;;;426      SetSysClockTo24();
;;;427    #elif defined SYSCLK_FREQ_36MHz
;;;428      SetSysClockTo36();
;;;429    #elif defined SYSCLK_FREQ_48MHz
;;;430      SetSysClockTo48();
;;;431    #elif defined SYSCLK_FREQ_56MHz
;;;432      SetSysClockTo56();  
;;;433    #elif defined SYSCLK_FREQ_72MHz
;;;434      SetSysClockTo72();
000196  f7fffffe          BL       SetSysClockTo72
;;;435    #endif
;;;436     
;;;437     /* If none of the define above is enabled, the HSI is used as System clock
;;;438        source (default after reset) */ 
;;;439    }
00019a  bd10              POP      {r4,pc}
;;;440    
                          ENDP

                  |L1.412|
                          DCD      0x40021000
                  |L1.416|
                          DCD      0xf8ff0000
                  |L1.420|
                          DCD      0xfef6ffff
                  |L1.424|
                          DCD      0xe000ed08
                  |L1.428|
                          DCD      0x007a1200
                  |L1.432|
                          DCD      SystemCoreClock
                  |L1.436|
                          DCD      0x00b71b00
                  |L1.440|
                          DCD      0x003d0900
                  |L1.444|
                          DCD      0x005b8d80
                  |L1.448|
                          DCD      AHBPrescTable
                  |L1.452|
                          DCD      0x40022000

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x03d09000
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
