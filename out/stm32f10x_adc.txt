; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\out\stm32f10x_adc.o --depend=.\out\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\ARM\INC -ID:\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\out\stm32f10x_adc.crf stdperiph_driver\src\stm32f10x_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;178      */
;;;179    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;180    {
000002  4604              MOV      r4,r0
;;;181      /* Check the parameters */
;;;182      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;183      
;;;184      if (ADCx == ADC1)
000004  48fe              LDR      r0,|L1.1024|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;185      {
;;;186        /* Enable ADC1 reset state */
;;;187        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  1540              ASRS     r0,r0,#21
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;188        /* Release ADC1 from reset state */
;;;189        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000012  2100              MOVS     r1,#0
000014  1560              ASRS     r0,r4,#21
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e017              B        |L1.76|
                  |L1.28|
;;;190      }
;;;191      else if (ADCx == ADC2)
00001c  48f9              LDR      r0,|L1.1028|
00001e  4284              CMP      r4,r0
000020  d108              BNE      |L1.52|
;;;192      {
;;;193        /* Enable ADC2 reset state */
;;;194        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
000022  2101              MOVS     r1,#1
000024  1500              ASRS     r0,r0,#20
000026  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;195        /* Release ADC2 from reset state */
;;;196        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  1520              ASRS     r0,r4,#20
00002e  f7fffffe          BL       RCC_APB2PeriphResetCmd
000032  e00b              B        |L1.76|
                  |L1.52|
;;;197      }
;;;198      else
;;;199      {
;;;200        if (ADCx == ADC3)
000034  48f4              LDR      r0,|L1.1032|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L1.76|
;;;201        {
;;;202          /* Enable ADC3 reset state */
;;;203          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  03c8              LSLS     r0,r1,#15
00003e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;204          /* Release ADC3 from reset state */
;;;205          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
000042  2100              MOVS     r1,#0
000044  f44f4000          MOV      r0,#0x8000
000048  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.76|
;;;206        }
;;;207      }
;;;208    }
00004c  bd10              POP      {r4,pc}
;;;209    
                          ENDP

                  ADC_Init PROC
;;;217      */
;;;218    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
00004e  b530              PUSH     {r4,r5,lr}
;;;219    {
;;;220      uint32_t tmpreg1 = 0;
000050  2200              MOVS     r2,#0
;;;221      uint8_t tmpreg2 = 0;
000052  2300              MOVS     r3,#0
;;;222      /* Check the parameters */
;;;223      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;224      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;225      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;226      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
;;;227      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;228      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;229      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;230    
;;;231      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;232      /* Get the ADCx CR1 value */
;;;233      tmpreg1 = ADCx->CR1;
000054  6842              LDR      r2,[r0,#4]
;;;234      /* Clear DUALMOD and SCAN bits */
;;;235      tmpreg1 &= CR1_CLEAR_Mask;
000056  4ced              LDR      r4,|L1.1036|
000058  4022              ANDS     r2,r2,r4
;;;236      /* Configure ADCx: Dual mode and scan conversion mode */
;;;237      /* Set DUALMOD bits according to ADC_Mode value */
;;;238      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;239      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
00005a  790d              LDRB     r5,[r1,#4]
00005c  680c              LDR      r4,[r1,#0]
00005e  ea442405          ORR      r4,r4,r5,LSL #8
000062  4322              ORRS     r2,r2,r4
;;;240      /* Write to ADCx CR1 */
;;;241      ADCx->CR1 = tmpreg1;
000064  6042              STR      r2,[r0,#4]
;;;242    
;;;243      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;244      /* Get the ADCx CR2 value */
;;;245      tmpreg1 = ADCx->CR2;
000066  6882              LDR      r2,[r0,#8]
;;;246      /* Clear CONT, ALIGN and EXTSEL bits */
;;;247      tmpreg1 &= CR2_CLEAR_Mask;
000068  4ce9              LDR      r4,|L1.1040|
00006a  4022              ANDS     r2,r2,r4
;;;248      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;249      /* Set ALIGN bit according to ADC_DataAlign value */
;;;250      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;251      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;252      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
00006c  e9d15402          LDRD     r5,r4,[r1,#8]
000070  432c              ORRS     r4,r4,r5
000072  794d              LDRB     r5,[r1,#5]
000074  ea440445          ORR      r4,r4,r5,LSL #1
000078  4322              ORRS     r2,r2,r4
;;;253                ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;254      /* Write to ADCx CR2 */
;;;255      ADCx->CR2 = tmpreg1;
00007a  6082              STR      r2,[r0,#8]
;;;256    
;;;257      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;258      /* Get the ADCx SQR1 value */
;;;259      tmpreg1 = ADCx->SQR1;
00007c  6ac2              LDR      r2,[r0,#0x2c]
;;;260      /* Clear L bits */
;;;261      tmpreg1 &= SQR1_CLEAR_Mask;
00007e  f4220270          BIC      r2,r2,#0xf00000
;;;262      /* Configure ADCx: regular channel sequence length */
;;;263      /* Set L bits according to ADC_NbrOfChannel value */
;;;264      tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
000082  7c0c              LDRB     r4,[r1,#0x10]
000084  1e64              SUBS     r4,r4,#1
000086  b2e4              UXTB     r4,r4
000088  4323              ORRS     r3,r3,r4
;;;265      tmpreg1 |= (uint32_t)tmpreg2 << 20;
00008a  ea425203          ORR      r2,r2,r3,LSL #20
;;;266      /* Write to ADCx SQR1 */
;;;267      ADCx->SQR1 = tmpreg1;
00008e  62c2              STR      r2,[r0,#0x2c]
;;;268    }
000090  bd30              POP      {r4,r5,pc}
;;;269    
                          ENDP

                  ADC_StructInit PROC
;;;274      */
;;;275    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000092  2100              MOVS     r1,#0
;;;276    {
;;;277      /* Reset ADC init structure parameters values */
;;;278      /* Initialize the ADC_Mode member */
;;;279      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
000094  6001              STR      r1,[r0,#0]
;;;280      /* initialize the ADC_ScanConvMode member */
;;;281      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000096  7101              STRB     r1,[r0,#4]
;;;282      /* Initialize the ADC_ContinuousConvMode member */
;;;283      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000098  7141              STRB     r1,[r0,#5]
;;;284      /* Initialize the ADC_ExternalTrigConv member */
;;;285      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
00009a  6081              STR      r1,[r0,#8]
;;;286      /* Initialize the ADC_DataAlign member */
;;;287      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00009c  60c1              STR      r1,[r0,#0xc]
;;;288      /* Initialize the ADC_NbrOfChannel member */
;;;289      ADC_InitStruct->ADC_NbrOfChannel = 1;
00009e  2101              MOVS     r1,#1
0000a0  7401              STRB     r1,[r0,#0x10]
;;;290    }
0000a2  4770              BX       lr
;;;291    
                          ENDP

                  ADC_Cmd PROC
;;;298      */
;;;299    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000a4  b121              CBZ      r1,|L1.176|
;;;300    {
;;;301      /* Check the parameters */
;;;302      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;303      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;304      if (NewState != DISABLE)
;;;305      {
;;;306        /* Set the ADON bit to wake up the ADC from power down mode */
;;;307        ADCx->CR2 |= CR2_ADON_Set;
0000a6  6882              LDR      r2,[r0,#8]
0000a8  f0420201          ORR      r2,r2,#1
0000ac  6082              STR      r2,[r0,#8]
0000ae  e003              B        |L1.184|
                  |L1.176|
;;;308      }
;;;309      else
;;;310      {
;;;311        /* Disable the selected ADC peripheral */
;;;312        ADCx->CR2 &= CR2_ADON_Reset;
0000b0  6882              LDR      r2,[r0,#8]
0000b2  f0220201          BIC      r2,r2,#1
0000b6  6082              STR      r2,[r0,#8]
                  |L1.184|
;;;313      }
;;;314    }
0000b8  4770              BX       lr
;;;315    
                          ENDP

                  ADC_DMACmd PROC
;;;323      */
;;;324    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000ba  b121              CBZ      r1,|L1.198|
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;328      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;329      if (NewState != DISABLE)
;;;330      {
;;;331        /* Enable the selected ADC DMA request */
;;;332        ADCx->CR2 |= CR2_DMA_Set;
0000bc  6882              LDR      r2,[r0,#8]
0000be  f4427280          ORR      r2,r2,#0x100
0000c2  6082              STR      r2,[r0,#8]
0000c4  e003              B        |L1.206|
                  |L1.198|
;;;333      }
;;;334      else
;;;335      {
;;;336        /* Disable the selected ADC DMA request */
;;;337        ADCx->CR2 &= CR2_DMA_Reset;
0000c6  6882              LDR      r2,[r0,#8]
0000c8  f4227280          BIC      r2,r2,#0x100
0000cc  6082              STR      r2,[r0,#8]
                  |L1.206|
;;;338      }
;;;339    }
0000ce  4770              BX       lr
;;;340    
                          ENDP

                  ADC_ITConfig PROC
;;;352      */
;;;353    void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
0000d0  b510              PUSH     {r4,lr}
;;;354    {
;;;355      uint8_t itmask = 0;
0000d2  2300              MOVS     r3,#0
;;;356      /* Check the parameters */
;;;357      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;358      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;359      assert_param(IS_ADC_IT(ADC_IT));
;;;360      /* Get the ADC IT index */
;;;361      itmask = (uint8_t)ADC_IT;
0000d4  b2cb              UXTB     r3,r1
;;;362      if (NewState != DISABLE)
0000d6  b11a              CBZ      r2,|L1.224|
;;;363      {
;;;364        /* Enable the selected ADC interrupts */
;;;365        ADCx->CR1 |= itmask;
0000d8  6844              LDR      r4,[r0,#4]
0000da  431c              ORRS     r4,r4,r3
0000dc  6044              STR      r4,[r0,#4]
0000de  e002              B        |L1.230|
                  |L1.224|
;;;366      }
;;;367      else
;;;368      {
;;;369        /* Disable the selected ADC interrupts */
;;;370        ADCx->CR1 &= (~(uint32_t)itmask);
0000e0  6844              LDR      r4,[r0,#4]
0000e2  439c              BICS     r4,r4,r3
0000e4  6044              STR      r4,[r0,#4]
                  |L1.230|
;;;371      }
;;;372    }
0000e6  bd10              POP      {r4,pc}
;;;373    
                          ENDP

                  ADC_ResetCalibration PROC
;;;378      */
;;;379    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
0000e8  6881              LDR      r1,[r0,#8]
;;;380    {
;;;381      /* Check the parameters */
;;;382      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;383      /* Resets the selected ADC calibration registers */  
;;;384      ADCx->CR2 |= CR2_RSTCAL_Set;
0000ea  f0410108          ORR      r1,r1,#8
0000ee  6081              STR      r1,[r0,#8]
;;;385    }
0000f0  4770              BX       lr
;;;386    
                          ENDP

                  ADC_GetResetCalibrationStatus PROC
;;;391      */
;;;392    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
0000f2  4601              MOV      r1,r0
;;;393    {
;;;394      FlagStatus bitstatus = RESET;
0000f4  2000              MOVS     r0,#0
;;;395      /* Check the parameters */
;;;396      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;397      /* Check the status of RSTCAL bit */
;;;398      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
0000f6  688a              LDR      r2,[r1,#8]
0000f8  f0120f08          TST      r2,#8
0000fc  d001              BEQ      |L1.258|
;;;399      {
;;;400        /* RSTCAL bit is set */
;;;401        bitstatus = SET;
0000fe  2001              MOVS     r0,#1
000100  e000              B        |L1.260|
                  |L1.258|
;;;402      }
;;;403      else
;;;404      {
;;;405        /* RSTCAL bit is reset */
;;;406        bitstatus = RESET;
000102  2000              MOVS     r0,#0
                  |L1.260|
;;;407      }
;;;408      /* Return the RSTCAL bit status */
;;;409      return  bitstatus;
;;;410    }
000104  4770              BX       lr
;;;411    
                          ENDP

                  ADC_StartCalibration PROC
;;;416      */
;;;417    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000106  6881              LDR      r1,[r0,#8]
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;421      /* Enable the selected ADC calibration process */  
;;;422      ADCx->CR2 |= CR2_CAL_Set;
000108  f0410104          ORR      r1,r1,#4
00010c  6081              STR      r1,[r0,#8]
;;;423    }
00010e  4770              BX       lr
;;;424    
                          ENDP

                  ADC_GetCalibrationStatus PROC
;;;429      */
;;;430    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000110  4601              MOV      r1,r0
;;;431    {
;;;432      FlagStatus bitstatus = RESET;
000112  2000              MOVS     r0,#0
;;;433      /* Check the parameters */
;;;434      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;435      /* Check the status of CAL bit */
;;;436      if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
000114  688a              LDR      r2,[r1,#8]
000116  f0120f04          TST      r2,#4
00011a  d001              BEQ      |L1.288|
;;;437      {
;;;438        /* CAL bit is set: calibration on going */
;;;439        bitstatus = SET;
00011c  2001              MOVS     r0,#1
00011e  e000              B        |L1.290|
                  |L1.288|
;;;440      }
;;;441      else
;;;442      {
;;;443        /* CAL bit is reset: end of calibration */
;;;444        bitstatus = RESET;
000120  2000              MOVS     r0,#0
                  |L1.290|
;;;445      }
;;;446      /* Return the CAL bit status */
;;;447      return  bitstatus;
;;;448    }
000122  4770              BX       lr
;;;449    
                          ENDP

                  ADC_SoftwareStartConvCmd PROC
;;;456      */
;;;457    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000124  b121              CBZ      r1,|L1.304|
;;;458    {
;;;459      /* Check the parameters */
;;;460      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;461      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;462      if (NewState != DISABLE)
;;;463      {
;;;464        /* Enable the selected ADC conversion on external event and start the selected
;;;465           ADC conversion */
;;;466        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
000126  6882              LDR      r2,[r0,#8]
000128  f44202a0          ORR      r2,r2,#0x500000
00012c  6082              STR      r2,[r0,#8]
00012e  e003              B        |L1.312|
                  |L1.304|
;;;467      }
;;;468      else
;;;469      {
;;;470        /* Disable the selected ADC conversion on external event and stop the selected
;;;471           ADC conversion */
;;;472        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
000130  6882              LDR      r2,[r0,#8]
000132  f42202a0          BIC      r2,r2,#0x500000
000136  6082              STR      r2,[r0,#8]
                  |L1.312|
;;;473      }
;;;474    }
000138  4770              BX       lr
;;;475    
                          ENDP

                  ADC_GetSoftwareStartConvStatus PROC
;;;480      */
;;;481    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
00013a  4601              MOV      r1,r0
;;;482    {
;;;483      FlagStatus bitstatus = RESET;
00013c  2000              MOVS     r0,#0
;;;484      /* Check the parameters */
;;;485      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;486      /* Check the status of SWSTART bit */
;;;487      if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
00013e  688a              LDR      r2,[r1,#8]
000140  f4120f80          TST      r2,#0x400000
000144  d001              BEQ      |L1.330|
;;;488      {
;;;489        /* SWSTART bit is set */
;;;490        bitstatus = SET;
000146  2001              MOVS     r0,#1
000148  e000              B        |L1.332|
                  |L1.330|
;;;491      }
;;;492      else
;;;493      {
;;;494        /* SWSTART bit is reset */
;;;495        bitstatus = RESET;
00014a  2000              MOVS     r0,#0
                  |L1.332|
;;;496      }
;;;497      /* Return the SWSTART bit status */
;;;498      return  bitstatus;
;;;499    }
00014c  4770              BX       lr
;;;500    
                          ENDP

                  ADC_DiscModeChannelCountConfig PROC
;;;508      */
;;;509    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
00014e  b510              PUSH     {r4,lr}
;;;510    {
;;;511      uint32_t tmpreg1 = 0;
000150  2200              MOVS     r2,#0
;;;512      uint32_t tmpreg2 = 0;
000152  2300              MOVS     r3,#0
;;;513      /* Check the parameters */
;;;514      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;515      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;516      /* Get the old register value */
;;;517      tmpreg1 = ADCx->CR1;
000154  6842              LDR      r2,[r0,#4]
;;;518      /* Clear the old discontinuous mode channel count */
;;;519      tmpreg1 &= CR1_DISCNUM_Reset;
000156  f4224260          BIC      r2,r2,#0xe000
;;;520      /* Set the discontinuous mode channel count */
;;;521      tmpreg2 = Number - 1;
00015a  1e4b              SUBS     r3,r1,#1
;;;522      tmpreg1 |= tmpreg2 << 13;
00015c  ea423243          ORR      r2,r2,r3,LSL #13
;;;523      /* Store the new register value */
;;;524      ADCx->CR1 = tmpreg1;
000160  6042              STR      r2,[r0,#4]
;;;525    }
000162  bd10              POP      {r4,pc}
;;;526    
                          ENDP

                  ADC_DiscModeCmd PROC
;;;535      */
;;;536    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000164  b121              CBZ      r1,|L1.368|
;;;537    {
;;;538      /* Check the parameters */
;;;539      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      if (NewState != DISABLE)
;;;542      {
;;;543        /* Enable the selected ADC regular discontinuous mode */
;;;544        ADCx->CR1 |= CR1_DISCEN_Set;
000166  6842              LDR      r2,[r0,#4]
000168  f4426200          ORR      r2,r2,#0x800
00016c  6042              STR      r2,[r0,#4]
00016e  e003              B        |L1.376|
                  |L1.368|
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the selected ADC regular discontinuous mode */
;;;549        ADCx->CR1 &= CR1_DISCEN_Reset;
000170  6842              LDR      r2,[r0,#4]
000172  f4226200          BIC      r2,r2,#0x800
000176  6042              STR      r2,[r0,#4]
                  |L1.376|
;;;550      }
;;;551    }
000178  4770              BX       lr
;;;552    
                          ENDP

                  ADC_RegularChannelConfig PROC
;;;589      */
;;;590    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
00017a  b5f0              PUSH     {r4-r7,lr}
;;;591    {
;;;592      uint32_t tmpreg1 = 0, tmpreg2 = 0;
00017c  2400              MOVS     r4,#0
00017e  2500              MOVS     r5,#0
;;;593      /* Check the parameters */
;;;594      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;595      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;596      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;597      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;598      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;599      if (ADC_Channel > ADC_Channel_9)
000180  2909              CMP      r1,#9
000182  dd11              BLE      |L1.424|
;;;600      {
;;;601        /* Get the old register value */
;;;602        tmpreg1 = ADCx->SMPR1;
000184  68c4              LDR      r4,[r0,#0xc]
;;;603        /* Calculate the mask to clear */
;;;604        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
000186  f1a1060a          SUB      r6,r1,#0xa
00018a  eb060746          ADD      r7,r6,r6,LSL #1
00018e  2607              MOVS     r6,#7
000190  fa06f507          LSL      r5,r6,r7
;;;605        /* Clear the old channel sample time */
;;;606        tmpreg1 &= ~tmpreg2;
000194  43ac              BICS     r4,r4,r5
;;;607        /* Calculate the mask to set */
;;;608        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000196  f1a1060a          SUB      r6,r1,#0xa
00019a  eb060646          ADD      r6,r6,r6,LSL #1
00019e  fa03f506          LSL      r5,r3,r6
;;;609        /* Set the new channel sample time */
;;;610        tmpreg1 |= tmpreg2;
0001a2  432c              ORRS     r4,r4,r5
;;;611        /* Store the new register value */
;;;612        ADCx->SMPR1 = tmpreg1;
0001a4  60c4              STR      r4,[r0,#0xc]
0001a6  e00c              B        |L1.450|
                  |L1.424|
;;;613      }
;;;614      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;615      {
;;;616        /* Get the old register value */
;;;617        tmpreg1 = ADCx->SMPR2;
0001a8  6904              LDR      r4,[r0,#0x10]
;;;618        /* Calculate the mask to clear */
;;;619        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
0001aa  eb010741          ADD      r7,r1,r1,LSL #1
0001ae  2607              MOVS     r6,#7
0001b0  fa06f507          LSL      r5,r6,r7
;;;620        /* Clear the old channel sample time */
;;;621        tmpreg1 &= ~tmpreg2;
0001b4  43ac              BICS     r4,r4,r5
;;;622        /* Calculate the mask to set */
;;;623        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
0001b6  eb010641          ADD      r6,r1,r1,LSL #1
0001ba  fa03f506          LSL      r5,r3,r6
;;;624        /* Set the new channel sample time */
;;;625        tmpreg1 |= tmpreg2;
0001be  432c              ORRS     r4,r4,r5
;;;626        /* Store the new register value */
;;;627        ADCx->SMPR2 = tmpreg1;
0001c0  6104              STR      r4,[r0,#0x10]
                  |L1.450|
;;;628      }
;;;629      /* For Rank 1 to 6 */
;;;630      if (Rank < 7)
0001c2  2a07              CMP      r2,#7
0001c4  da0f              BGE      |L1.486|
;;;631      {
;;;632        /* Get the old register value */
;;;633        tmpreg1 = ADCx->SQR3;
0001c6  6b44              LDR      r4,[r0,#0x34]
;;;634        /* Calculate the mask to clear */
;;;635        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
0001c8  1e56              SUBS     r6,r2,#1
0001ca  eb060786          ADD      r7,r6,r6,LSL #2
0001ce  261f              MOVS     r6,#0x1f
0001d0  fa06f507          LSL      r5,r6,r7
;;;636        /* Clear the old SQx bits for the selected rank */
;;;637        tmpreg1 &= ~tmpreg2;
0001d4  43ac              BICS     r4,r4,r5
;;;638        /* Calculate the mask to set */
;;;639        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
0001d6  1e56              SUBS     r6,r2,#1
0001d8  eb060686          ADD      r6,r6,r6,LSL #2
0001dc  fa01f506          LSL      r5,r1,r6
;;;640        /* Set the SQx bits for the selected rank */
;;;641        tmpreg1 |= tmpreg2;
0001e0  432c              ORRS     r4,r4,r5
;;;642        /* Store the new register value */
;;;643        ADCx->SQR3 = tmpreg1;
0001e2  6344              STR      r4,[r0,#0x34]
0001e4  e022              B        |L1.556|
                  |L1.486|
;;;644      }
;;;645      /* For Rank 7 to 12 */
;;;646      else if (Rank < 13)
0001e6  2a0d              CMP      r2,#0xd
0001e8  da0f              BGE      |L1.522|
;;;647      {
;;;648        /* Get the old register value */
;;;649        tmpreg1 = ADCx->SQR2;
0001ea  6b04              LDR      r4,[r0,#0x30]
;;;650        /* Calculate the mask to clear */
;;;651        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
0001ec  1fd6              SUBS     r6,r2,#7
0001ee  eb060786          ADD      r7,r6,r6,LSL #2
0001f2  261f              MOVS     r6,#0x1f
0001f4  fa06f507          LSL      r5,r6,r7
;;;652        /* Clear the old SQx bits for the selected rank */
;;;653        tmpreg1 &= ~tmpreg2;
0001f8  43ac              BICS     r4,r4,r5
;;;654        /* Calculate the mask to set */
;;;655        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
0001fa  1fd6              SUBS     r6,r2,#7
0001fc  eb060686          ADD      r6,r6,r6,LSL #2
000200  fa01f506          LSL      r5,r1,r6
;;;656        /* Set the SQx bits for the selected rank */
;;;657        tmpreg1 |= tmpreg2;
000204  432c              ORRS     r4,r4,r5
;;;658        /* Store the new register value */
;;;659        ADCx->SQR2 = tmpreg1;
000206  6304              STR      r4,[r0,#0x30]
000208  e010              B        |L1.556|
                  |L1.522|
;;;660      }
;;;661      /* For Rank 13 to 16 */
;;;662      else
;;;663      {
;;;664        /* Get the old register value */
;;;665        tmpreg1 = ADCx->SQR1;
00020a  6ac4              LDR      r4,[r0,#0x2c]
;;;666        /* Calculate the mask to clear */
;;;667        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
00020c  f1a2060d          SUB      r6,r2,#0xd
000210  eb060786          ADD      r7,r6,r6,LSL #2
000214  261f              MOVS     r6,#0x1f
000216  fa06f507          LSL      r5,r6,r7
;;;668        /* Clear the old SQx bits for the selected rank */
;;;669        tmpreg1 &= ~tmpreg2;
00021a  43ac              BICS     r4,r4,r5
;;;670        /* Calculate the mask to set */
;;;671        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
00021c  f1a2060d          SUB      r6,r2,#0xd
000220  eb060686          ADD      r6,r6,r6,LSL #2
000224  fa01f506          LSL      r5,r1,r6
;;;672        /* Set the SQx bits for the selected rank */
;;;673        tmpreg1 |= tmpreg2;
000228  432c              ORRS     r4,r4,r5
;;;674        /* Store the new register value */
;;;675        ADCx->SQR1 = tmpreg1;
00022a  62c4              STR      r4,[r0,#0x2c]
                  |L1.556|
;;;676      }
;;;677    }
00022c  bdf0              POP      {r4-r7,pc}
;;;678    
                          ENDP

                  ADC_ExternalTrigConvCmd PROC
;;;685      */
;;;686    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00022e  b121              CBZ      r1,|L1.570|
;;;687    {
;;;688      /* Check the parameters */
;;;689      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;690      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;691      if (NewState != DISABLE)
;;;692      {
;;;693        /* Enable the selected ADC conversion on external event */
;;;694        ADCx->CR2 |= CR2_EXTTRIG_Set;
000230  6882              LDR      r2,[r0,#8]
000232  f4421280          ORR      r2,r2,#0x100000
000236  6082              STR      r2,[r0,#8]
000238  e003              B        |L1.578|
                  |L1.570|
;;;695      }
;;;696      else
;;;697      {
;;;698        /* Disable the selected ADC conversion on external event */
;;;699        ADCx->CR2 &= CR2_EXTTRIG_Reset;
00023a  6882              LDR      r2,[r0,#8]
00023c  f4221280          BIC      r2,r2,#0x100000
000240  6082              STR      r2,[r0,#8]
                  |L1.578|
;;;700      }
;;;701    }
000242  4770              BX       lr
;;;702    
                          ENDP

                  ADC_GetConversionValue PROC
;;;707      */
;;;708    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000244  4601              MOV      r1,r0
;;;709    {
;;;710      /* Check the parameters */
;;;711      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;712      /* Return the selected ADC conversion value */
;;;713      return (uint16_t) ADCx->DR;
000246  6cc8              LDR      r0,[r1,#0x4c]
000248  b280              UXTH     r0,r0
;;;714    }
00024a  4770              BX       lr
;;;715    
                          ENDP

                  ADC_GetDualModeConversionValue PROC
;;;719      */
;;;720    uint32_t ADC_GetDualModeConversionValue(void)
00024c  4871              LDR      r0,|L1.1044|
;;;721    {
;;;722      /* Return the dual mode conversion value */
;;;723      return (*(__IO uint32_t *) DR_ADDRESS);
00024e  6800              LDR      r0,[r0,#0]
;;;724    }
000250  4770              BX       lr
;;;725    
                          ENDP

                  ADC_AutoInjectedConvCmd PROC
;;;733      */
;;;734    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000252  b121              CBZ      r1,|L1.606|
;;;735    {
;;;736      /* Check the parameters */
;;;737      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;738      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;739      if (NewState != DISABLE)
;;;740      {
;;;741        /* Enable the selected ADC automatic injected group conversion */
;;;742        ADCx->CR1 |= CR1_JAUTO_Set;
000254  6842              LDR      r2,[r0,#4]
000256  f4426280          ORR      r2,r2,#0x400
00025a  6042              STR      r2,[r0,#4]
00025c  e003              B        |L1.614|
                  |L1.606|
;;;743      }
;;;744      else
;;;745      {
;;;746        /* Disable the selected ADC automatic injected group conversion */
;;;747        ADCx->CR1 &= CR1_JAUTO_Reset;
00025e  6842              LDR      r2,[r0,#4]
000260  f4226280          BIC      r2,r2,#0x400
000264  6042              STR      r2,[r0,#4]
                  |L1.614|
;;;748      }
;;;749    }
000266  4770              BX       lr
;;;750    
                          ENDP

                  ADC_InjectedDiscModeCmd PROC
;;;759      */
;;;760    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000268  b121              CBZ      r1,|L1.628|
;;;761    {
;;;762      /* Check the parameters */
;;;763      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;764      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;765      if (NewState != DISABLE)
;;;766      {
;;;767        /* Enable the selected ADC injected discontinuous mode */
;;;768        ADCx->CR1 |= CR1_JDISCEN_Set;
00026a  6842              LDR      r2,[r0,#4]
00026c  f4425280          ORR      r2,r2,#0x1000
000270  6042              STR      r2,[r0,#4]
000272  e003              B        |L1.636|
                  |L1.628|
;;;769      }
;;;770      else
;;;771      {
;;;772        /* Disable the selected ADC injected discontinuous mode */
;;;773        ADCx->CR1 &= CR1_JDISCEN_Reset;
000274  6842              LDR      r2,[r0,#4]
000276  f4225280          BIC      r2,r2,#0x1000
00027a  6042              STR      r2,[r0,#4]
                  |L1.636|
;;;774      }
;;;775    }
00027c  4770              BX       lr
;;;776    
                          ENDP

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;798      */
;;;799    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
00027e  2200              MOVS     r2,#0
;;;800    {
;;;801      uint32_t tmpreg = 0;
;;;802      /* Check the parameters */
;;;803      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;804      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;805      /* Get the old register value */
;;;806      tmpreg = ADCx->CR2;
000280  6882              LDR      r2,[r0,#8]
;;;807      /* Clear the old external event selection for injected group */
;;;808      tmpreg &= CR2_JEXTSEL_Reset;
000282  f42242e0          BIC      r2,r2,#0x7000
;;;809      /* Set the external event selection for injected group */
;;;810      tmpreg |= ADC_ExternalTrigInjecConv;
000286  430a              ORRS     r2,r2,r1
;;;811      /* Store the new register value */
;;;812      ADCx->CR2 = tmpreg;
000288  6082              STR      r2,[r0,#8]
;;;813    }
00028a  4770              BX       lr
;;;814    
                          ENDP

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;823      */
;;;824    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00028c  b121              CBZ      r1,|L1.664|
;;;825    {
;;;826      /* Check the parameters */
;;;827      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;828      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;829      if (NewState != DISABLE)
;;;830      {
;;;831        /* Enable the selected ADC external event selection for injected group */
;;;832        ADCx->CR2 |= CR2_JEXTTRIG_Set;
00028e  6882              LDR      r2,[r0,#8]
000290  f4424200          ORR      r2,r2,#0x8000
000294  6082              STR      r2,[r0,#8]
000296  e003              B        |L1.672|
                  |L1.664|
;;;833      }
;;;834      else
;;;835      {
;;;836        /* Disable the selected ADC external event selection for injected group */
;;;837        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
000298  6882              LDR      r2,[r0,#8]
00029a  f4224200          BIC      r2,r2,#0x8000
00029e  6082              STR      r2,[r0,#8]
                  |L1.672|
;;;838      }
;;;839    }
0002a0  4770              BX       lr
;;;840    
                          ENDP

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;848      */
;;;849    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0002a2  b121              CBZ      r1,|L1.686|
;;;850    {
;;;851      /* Check the parameters */
;;;852      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;853      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;854      if (NewState != DISABLE)
;;;855      {
;;;856        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;857           ADC injected conversion */
;;;858        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
0002a4  6882              LDR      r2,[r0,#8]
0002a6  f4421202          ORR      r2,r2,#0x208000
0002aa  6082              STR      r2,[r0,#8]
0002ac  e003              B        |L1.694|
                  |L1.686|
;;;859      }
;;;860      else
;;;861      {
;;;862        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;863           ADC injected conversion */
;;;864        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
0002ae  6882              LDR      r2,[r0,#8]
0002b0  f4221202          BIC      r2,r2,#0x208000
0002b4  6082              STR      r2,[r0,#8]
                  |L1.694|
;;;865      }
;;;866    }
0002b6  4770              BX       lr
;;;867    
                          ENDP

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;872      */
;;;873    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
0002b8  4601              MOV      r1,r0
;;;874    {
;;;875      FlagStatus bitstatus = RESET;
0002ba  2000              MOVS     r0,#0
;;;876      /* Check the parameters */
;;;877      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;878      /* Check the status of JSWSTART bit */
;;;879      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
0002bc  688a              LDR      r2,[r1,#8]
0002be  f4121f00          TST      r2,#0x200000
0002c2  d001              BEQ      |L1.712|
;;;880      {
;;;881        /* JSWSTART bit is set */
;;;882        bitstatus = SET;
0002c4  2001              MOVS     r0,#1
0002c6  e000              B        |L1.714|
                  |L1.712|
;;;883      }
;;;884      else
;;;885      {
;;;886        /* JSWSTART bit is reset */
;;;887        bitstatus = RESET;
0002c8  2000              MOVS     r0,#0
                  |L1.714|
;;;888      }
;;;889      /* Return the JSWSTART bit status */
;;;890      return  bitstatus;
;;;891    }
0002ca  4770              BX       lr
;;;892    
                          ENDP

                  ADC_InjectedChannelConfig PROC
;;;929      */
;;;930    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
0002cc  b5f0              PUSH     {r4-r7,lr}
;;;931    {
;;;932      uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
0002ce  2400              MOVS     r4,#0
0002d0  2500              MOVS     r5,#0
0002d2  2600              MOVS     r6,#0
;;;933      /* Check the parameters */
;;;934      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;935      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;936      assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;937      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;938      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;939      if (ADC_Channel > ADC_Channel_9)
0002d4  2909              CMP      r1,#9
0002d6  dd11              BLE      |L1.764|
;;;940      {
;;;941        /* Get the old register value */
;;;942        tmpreg1 = ADCx->SMPR1;
0002d8  68c4              LDR      r4,[r0,#0xc]
;;;943        /* Calculate the mask to clear */
;;;944        tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
0002da  f1a1070a          SUB      r7,r1,#0xa
0002de  eb070c47          ADD      r12,r7,r7,LSL #1
0002e2  2707              MOVS     r7,#7
0002e4  fa07f50c          LSL      r5,r7,r12
;;;945        /* Clear the old channel sample time */
;;;946        tmpreg1 &= ~tmpreg2;
0002e8  43ac              BICS     r4,r4,r5
;;;947        /* Calculate the mask to set */
;;;948        tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
0002ea  f1a1070a          SUB      r7,r1,#0xa
0002ee  eb070747          ADD      r7,r7,r7,LSL #1
0002f2  fa03f507          LSL      r5,r3,r7
;;;949        /* Set the new channel sample time */
;;;950        tmpreg1 |= tmpreg2;
0002f6  432c              ORRS     r4,r4,r5
;;;951        /* Store the new register value */
;;;952        ADCx->SMPR1 = tmpreg1;
0002f8  60c4              STR      r4,[r0,#0xc]
0002fa  e00c              B        |L1.790|
                  |L1.764|
;;;953      }
;;;954      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;955      {
;;;956        /* Get the old register value */
;;;957        tmpreg1 = ADCx->SMPR2;
0002fc  6904              LDR      r4,[r0,#0x10]
;;;958        /* Calculate the mask to clear */
;;;959        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
0002fe  eb010c41          ADD      r12,r1,r1,LSL #1
000302  2707              MOVS     r7,#7
000304  fa07f50c          LSL      r5,r7,r12
;;;960        /* Clear the old channel sample time */
;;;961        tmpreg1 &= ~tmpreg2;
000308  43ac              BICS     r4,r4,r5
;;;962        /* Calculate the mask to set */
;;;963        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
00030a  eb010741          ADD      r7,r1,r1,LSL #1
00030e  fa03f507          LSL      r5,r3,r7
;;;964        /* Set the new channel sample time */
;;;965        tmpreg1 |= tmpreg2;
000312  432c              ORRS     r4,r4,r5
;;;966        /* Store the new register value */
;;;967        ADCx->SMPR2 = tmpreg1;
000314  6104              STR      r4,[r0,#0x10]
                  |L1.790|
;;;968      }
;;;969      /* Rank configuration */
;;;970      /* Get the old register value */
;;;971      tmpreg1 = ADCx->JSQR;
000316  6b84              LDR      r4,[r0,#0x38]
;;;972      /* Get JL value: Number = JL+1 */
;;;973      tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
000318  f3c45601          UBFX     r6,r4,#20,#2
;;;974      /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;975      tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
00031c  1cd7              ADDS     r7,r2,#3
00031e  f1060c01          ADD      r12,r6,#1
000322  eba7070c          SUB      r7,r7,r12
000326  eb070c87          ADD      r12,r7,r7,LSL #2
00032a  271f              MOVS     r7,#0x1f
00032c  fa07f50c          LSL      r5,r7,r12
;;;976      /* Clear the old JSQx bits for the selected rank */
;;;977      tmpreg1 &= ~tmpreg2;
000330  43ac              BICS     r4,r4,r5
;;;978      /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;979      tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000332  1cd7              ADDS     r7,r2,#3
000334  f1060c01          ADD      r12,r6,#1
000338  eba7070c          SUB      r7,r7,r12
00033c  eb070787          ADD      r7,r7,r7,LSL #2
000340  fa01f507          LSL      r5,r1,r7
;;;980      /* Set the JSQx bits for the selected rank */
;;;981      tmpreg1 |= tmpreg2;
000344  432c              ORRS     r4,r4,r5
;;;982      /* Store the new register value */
;;;983      ADCx->JSQR = tmpreg1;
000346  6384              STR      r4,[r0,#0x38]
;;;984    }
000348  bdf0              POP      {r4-r7,pc}
;;;985    
                          ENDP

                  ADC_InjectedSequencerLengthConfig PROC
;;;992      */
;;;993    void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
00034a  b510              PUSH     {r4,lr}
;;;994    {
;;;995      uint32_t tmpreg1 = 0;
00034c  2200              MOVS     r2,#0
;;;996      uint32_t tmpreg2 = 0;
00034e  2300              MOVS     r3,#0
;;;997      /* Check the parameters */
;;;998      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;999      assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1000     
;;;1001     /* Get the old register value */
;;;1002     tmpreg1 = ADCx->JSQR;
000350  6b82              LDR      r2,[r0,#0x38]
;;;1003     /* Clear the old injected sequnence lenght JL bits */
;;;1004     tmpreg1 &= JSQR_JL_Reset;
000352  f4221240          BIC      r2,r2,#0x300000
;;;1005     /* Set the injected sequnence lenght JL bits */
;;;1006     tmpreg2 = Length - 1; 
000356  1e4b              SUBS     r3,r1,#1
;;;1007     tmpreg1 |= tmpreg2 << 20;
000358  ea425203          ORR      r2,r2,r3,LSL #20
;;;1008     /* Store the new register value */
;;;1009     ADCx->JSQR = tmpreg1;
00035c  6382              STR      r2,[r0,#0x38]
;;;1010   }
00035e  bd10              POP      {r4,pc}
;;;1011   
                          ENDP

                  ADC_SetInjectedOffset PROC
;;;1024     */
;;;1025   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000360  b510              PUSH     {r4,lr}
;;;1026   {
;;;1027     __IO uint32_t tmp = 0;
000362  2300              MOVS     r3,#0
;;;1028     
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1031     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1032     assert_param(IS_ADC_OFFSET(Offset));  
;;;1033     
;;;1034     tmp = (uint32_t)ADCx;
000364  4603              MOV      r3,r0
;;;1035     tmp += ADC_InjectedChannel;
000366  4618              MOV      r0,r3
000368  440b              ADD      r3,r3,r1
;;;1036     
;;;1037     /* Set the selected injected channel data offset */
;;;1038     *(__IO uint32_t *) tmp = (uint32_t)Offset;
00036a  601a              STR      r2,[r3,#0]
;;;1039   }
00036c  bd10              POP      {r4,pc}
;;;1040   
                          ENDP

                  ADC_GetInjectedConversionValue PROC
;;;1051     */
;;;1052   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
00036e  4602              MOV      r2,r0
;;;1053   {
;;;1054     __IO uint32_t tmp = 0;
000370  2300              MOVS     r3,#0
;;;1055     
;;;1056     /* Check the parameters */
;;;1057     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1058     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1059   
;;;1060     tmp = (uint32_t)ADCx;
000372  4613              MOV      r3,r2
;;;1061     tmp += ADC_InjectedChannel + JDR_Offset;
000374  461a              MOV      r2,r3
000376  f1010028          ADD      r0,r1,#0x28
00037a  4403              ADD      r3,r3,r0
;;;1062     
;;;1063     /* Returns the selected injected channel conversion data value */
;;;1064     return (uint16_t) (*(__IO uint32_t*)  tmp);   
00037c  6818              LDR      r0,[r3,#0]
00037e  b280              UXTH     r0,r0
;;;1065   }
000380  4770              BX       lr
;;;1066   
                          ENDP

                  ADC_AnalogWatchdogCmd PROC
;;;1081     */
;;;1082   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000382  2200              MOVS     r2,#0
;;;1083   {
;;;1084     uint32_t tmpreg = 0;
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1087     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;1088     /* Get the old register value */
;;;1089     tmpreg = ADCx->CR1;
000384  6842              LDR      r2,[r0,#4]
;;;1090     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1091     tmpreg &= CR1_AWDMode_Reset;
000386  4b24              LDR      r3,|L1.1048|
000388  401a              ANDS     r2,r2,r3
;;;1092     /* Set the analog watchdog enable mode */
;;;1093     tmpreg |= ADC_AnalogWatchdog;
00038a  430a              ORRS     r2,r2,r1
;;;1094     /* Store the new register value */
;;;1095     ADCx->CR1 = tmpreg;
00038c  6042              STR      r2,[r0,#4]
;;;1096   }
00038e  4770              BX       lr
;;;1097   
                          ENDP

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1106     */
;;;1107   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000390  6241              STR      r1,[r0,#0x24]
;;;1108                                           uint16_t LowThreshold)
;;;1109   {
;;;1110     /* Check the parameters */
;;;1111     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1112     assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;1113     assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;1114     /* Set the ADCx high threshold */
;;;1115     ADCx->HTR = HighThreshold;
;;;1116     /* Set the ADCx low threshold */
;;;1117     ADCx->LTR = LowThreshold;
000392  6282              STR      r2,[r0,#0x28]
;;;1118   }
000394  4770              BX       lr
;;;1119   
                          ENDP

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1144     */
;;;1145   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000396  2200              MOVS     r2,#0
;;;1146   {
;;;1147     uint32_t tmpreg = 0;
;;;1148     /* Check the parameters */
;;;1149     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1150     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1151     /* Get the old register value */
;;;1152     tmpreg = ADCx->CR1;
000398  6842              LDR      r2,[r0,#4]
;;;1153     /* Clear the Analog watchdog channel select bits */
;;;1154     tmpreg &= CR1_AWDCH_Reset;
00039a  f022021f          BIC      r2,r2,#0x1f
;;;1155     /* Set the Analog watchdog channel */
;;;1156     tmpreg |= ADC_Channel;
00039e  430a              ORRS     r2,r2,r1
;;;1157     /* Store the new register value */
;;;1158     ADCx->CR1 = tmpreg;
0003a0  6042              STR      r2,[r0,#4]
;;;1159   }
0003a2  4770              BX       lr
;;;1160   
                          ENDP

                  ADC_TempSensorVrefintCmd PROC
;;;1166     */
;;;1167   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
0003a4  b138              CBZ      r0,|L1.950|
;;;1168   {
;;;1169     /* Check the parameters */
;;;1170     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1171     if (NewState != DISABLE)
;;;1172     {
;;;1173       /* Enable the temperature sensor and Vrefint channel*/
;;;1174       ADC1->CR2 |= CR2_TSVREFE_Set;
0003a6  491d              LDR      r1,|L1.1052|
0003a8  6809              LDR      r1,[r1,#0]
0003aa  f4410100          ORR      r1,r1,#0x800000
0003ae  4a1c              LDR      r2,|L1.1056|
0003b0  f8c21408          STR      r1,[r2,#0x408]
0003b4  e006              B        |L1.964|
                  |L1.950|
;;;1175     }
;;;1176     else
;;;1177     {
;;;1178       /* Disable the temperature sensor and Vrefint channel*/
;;;1179       ADC1->CR2 &= CR2_TSVREFE_Reset;
0003b6  4919              LDR      r1,|L1.1052|
0003b8  6809              LDR      r1,[r1,#0]
0003ba  f4210100          BIC      r1,r1,#0x800000
0003be  4a18              LDR      r2,|L1.1056|
0003c0  f8c21408          STR      r1,[r2,#0x408]
                  |L1.964|
;;;1180     }
;;;1181   }
0003c4  4770              BX       lr
;;;1182   
                          ENDP

                  ADC_GetFlagStatus PROC
;;;1194     */
;;;1195   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
0003c6  4602              MOV      r2,r0
;;;1196   {
;;;1197     FlagStatus bitstatus = RESET;
0003c8  2000              MOVS     r0,#0
;;;1198     /* Check the parameters */
;;;1199     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1200     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1201     /* Check the status of the specified ADC flag */
;;;1202     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
0003ca  6813              LDR      r3,[r2,#0]
0003cc  420b              TST      r3,r1
0003ce  d001              BEQ      |L1.980|
;;;1203     {
;;;1204       /* ADC_FLAG is set */
;;;1205       bitstatus = SET;
0003d0  2001              MOVS     r0,#1
0003d2  e000              B        |L1.982|
                  |L1.980|
;;;1206     }
;;;1207     else
;;;1208     {
;;;1209       /* ADC_FLAG is reset */
;;;1210       bitstatus = RESET;
0003d4  2000              MOVS     r0,#0
                  |L1.982|
;;;1211     }
;;;1212     /* Return the ADC_FLAG status */
;;;1213     return  bitstatus;
;;;1214   }
0003d6  4770              BX       lr
;;;1215   
                          ENDP

                  ADC_ClearFlag PROC
;;;1227     */
;;;1228   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
0003d8  43ca              MVNS     r2,r1
;;;1229   {
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1232     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1233     /* Clear the selected ADC flags */
;;;1234     ADCx->SR = ~(uint32_t)ADC_FLAG;
0003da  6002              STR      r2,[r0,#0]
;;;1235   }
0003dc  4770              BX       lr
;;;1236   
                          ENDP

                  ADC_GetITStatus PROC
;;;1246     */
;;;1247   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
0003de  b570              PUSH     {r4-r6,lr}
;;;1248   {
0003e0  4602              MOV      r2,r0
;;;1249     ITStatus bitstatus = RESET;
0003e2  2000              MOVS     r0,#0
;;;1250     uint32_t itmask = 0, enablestatus = 0;
0003e4  2300              MOVS     r3,#0
0003e6  2400              MOVS     r4,#0
;;;1251     /* Check the parameters */
;;;1252     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1253     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1254     /* Get the ADC IT index */
;;;1255     itmask = ADC_IT >> 8;
0003e8  120b              ASRS     r3,r1,#8
;;;1256     /* Get the ADC_IT enable bit status */
;;;1257     enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
0003ea  6855              LDR      r5,[r2,#4]
0003ec  b2ce              UXTB     r6,r1
0003ee  ea050406          AND      r4,r5,r6
;;;1258     /* Check the status of the specified ADC interrupt */
;;;1259     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
0003f2  6815              LDR      r5,[r2,#0]
0003f4  421d              TST      r5,r3
0003f6  d015              BEQ      |L1.1060|
0003f8  b1a4              CBZ      r4,|L1.1060|
;;;1260     {
;;;1261       /* ADC_IT is set */
;;;1262       bitstatus = SET;
0003fa  2001              MOVS     r0,#1
0003fc  e013              B        |L1.1062|
0003fe  0000              DCW      0x0000
                  |L1.1024|
                          DCD      0x40012400
                  |L1.1028|
                          DCD      0x40012800
                  |L1.1032|
                          DCD      0x40013c00
                  |L1.1036|
                          DCD      0xfff0feff
                  |L1.1040|
                          DCD      0xfff1f7fd
                  |L1.1044|
                          DCD      0x4001244c
                  |L1.1048|
                          DCD      0xff3ffdff
                  |L1.1052|
                          DCD      0x40012408
                  |L1.1056|
                          DCD      0x40012000
                  |L1.1060|
;;;1263     }
;;;1264     else
;;;1265     {
;;;1266       /* ADC_IT is reset */
;;;1267       bitstatus = RESET;
000424  2000              MOVS     r0,#0
                  |L1.1062|
;;;1268     }
;;;1269     /* Return the ADC_IT status */
;;;1270     return  bitstatus;
;;;1271   }
000426  bd70              POP      {r4-r6,pc}
;;;1272   
                          ENDP

                  ADC_ClearITPendingBit PROC
;;;1282     */
;;;1283   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000428  2200              MOVS     r2,#0
;;;1284   {
;;;1285     uint8_t itmask = 0;
;;;1286     /* Check the parameters */
;;;1287     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1288     assert_param(IS_ADC_IT(ADC_IT));
;;;1289     /* Get the ADC IT index */
;;;1290     itmask = (uint8_t)(ADC_IT >> 8);
00042a  120a              ASRS     r2,r1,#8
;;;1291     /* Clear the selected ADC interrupt pending bits */
;;;1292     ADCx->SR = ~(uint32_t)itmask;
00042c  43d3              MVNS     r3,r2
00042e  6003              STR      r3,[r0,#0]
;;;1293   }
000430  4770              BX       lr
;;;1294   
                          ENDP

