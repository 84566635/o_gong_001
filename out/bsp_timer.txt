; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\out\bsp_timer.o --depend=.\out\bsp_timer.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\ARM\INC -ID:\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\out\bsp_timer.crf user\src\bsp_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  bsp_InitTimer PROC
;;;47     */
;;;48     void bsp_InitTimer(void)
000000  b510              PUSH     {r4,lr}
;;;49     {
;;;50     	uint8_t i;
;;;51     
;;;52     	/* 清零所有的软件定时器 */
;;;53     	for (i = 0; i < TMR_COUNT; i++)
000002  2000              MOVS     r0,#0
000004  e016              B        |L1.52|
                  |L1.6|
;;;54     	{
;;;55     		s_tTmr[i].Count = 0;
000006  2100              MOVS     r1,#0
000008  eb000240          ADD      r2,r0,r0,LSL #1
00000c  4bb2              LDR      r3,|L1.728|
00000e  eb030282          ADD      r2,r3,r2,LSL #2
000012  6051              STR      r1,[r2,#4]
;;;56     		s_tTmr[i].PreLoad = 0;
000014  eb000240          ADD      r2,r0,r0,LSL #1
000018  eb030282          ADD      r2,r3,r2,LSL #2
00001c  6091              STR      r1,[r2,#8]
;;;57     		s_tTmr[i].Flag = 0;
00001e  eb000240          ADD      r2,r0,r0,LSL #1
000022  eb030282          ADD      r2,r3,r2,LSL #2
000026  7051              STRB     r1,[r2,#1]
;;;58     		s_tTmr[i].Mode = TMR_ONCE_MODE;	/* 缺省是1次性工作模式 */
000028  eb000240          ADD      r2,r0,r0,LSL #1
00002c  f8031022          STRB     r1,[r3,r2,LSL #2]
000030  1c41              ADDS     r1,r0,#1              ;53
000032  b2c8              UXTB     r0,r1                 ;53
                  |L1.52|
000034  2804              CMP      r0,#4                 ;53
000036  dbe6              BLT      |L1.6|
;;;59     	}
;;;60     
;;;61     	/*
;;;62     		配置systic中断周期为1ms，并启动systick中断。
;;;63     
;;;64         	SystemCoreClock 是固件中定义的系统内核时钟，对于STM32F4XX,一般为 168MHz
;;;65     
;;;66         	SysTick_Config() 函数的形参表示内核时钟多少个周期后触发一次Systick定时中断.
;;;67     	    	-- SystemCoreClock / 1000  表示定时频率为 1000Hz， 也就是定时周期为  1ms
;;;68     	    	-- SystemCoreClock / 500   表示定时频率为 500Hz，  也就是定时周期为  2ms
;;;69     	    	-- SystemCoreClock / 2000  表示定时频率为 2000Hz， 也就是定时周期为  500us
;;;70     
;;;71         	对于常规的应用，我们一般取定时周期1ms。对于低速CPU或者低功耗应用，可以设置定时周期为 10ms
;;;72         */
;;;73     	SysTick_Config(SystemCoreClock / 800);//10ms
000038  4aa8              LDR      r2,|L1.732|
00003a  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
00003c  f44f7348          MOV      r3,#0x320
000040  fbb2f1f3          UDIV     r1,r2,r3
000044  f1b17f80          CMP      r1,#0x1000000
000048  d300              BCC      |L1.76|
00004a  e01c              B        |L1.134|
                  |L1.76|
00004c  f021427f          BIC      r2,r1,#0xff000000
000050  1e52              SUBS     r2,r2,#1
000052  f04f23e0          MOV      r3,#0xe000e000
000056  615a              STR      r2,[r3,#0x14]
000058  bf00              NOP      
00005a  175a              ASRS     r2,r3,#29
00005c  2a00              CMP      r2,#0
00005e  da05              BGE      |L1.108|
000060  220f              MOVS     r2,#0xf
000062  0112              LSLS     r2,r2,#4
000064  4b9e              LDR      r3,|L1.736|
000066  240b              MOVS     r4,#0xb
000068  551a              STRB     r2,[r3,r4]
00006a  e004              B        |L1.118|
                  |L1.108|
00006c  220f              MOVS     r2,#0xf
00006e  0112              LSLS     r2,r2,#4
000070  4b9c              LDR      r3,|L1.740|
000072  175c              ASRS     r4,r3,#29
000074  551a              STRB     r2,[r3,r4]
                  |L1.118|
000076  bf00              NOP      
000078  2200              MOVS     r2,#0
00007a  f04f23e0          MOV      r3,#0xe000e000
00007e  619a              STR      r2,[r3,#0x18]
000080  2207              MOVS     r2,#7
000082  611a              STR      r2,[r3,#0x10]
000084  bf00              NOP      
                  |L1.134|
;;;74     }
000086  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  bsp_SoftTimerDec PROC
;;;137    */
;;;138    static void bsp_SoftTimerDec(SOFT_TMR *_tmr)
000088  6841              LDR      r1,[r0,#4]
;;;139    {
;;;140    	if (_tmr->Count > 0)
00008a  b151              CBZ      r1,|L1.162|
;;;141    	{
;;;142    		/* 如果定时器变量减到1则设置定时器到达标志 */
;;;143    		if (--_tmr->Count == 0)
00008c  6841              LDR      r1,[r0,#4]
00008e  1e49              SUBS     r1,r1,#1
000090  6041              STR      r1,[r0,#4]
000092  d106              BNE      |L1.162|
;;;144    		{
;;;145    			_tmr->Flag = 1;
000094  2101              MOVS     r1,#1
000096  7041              STRB     r1,[r0,#1]
;;;146    
;;;147    			/* 如果是自动模式，则自动重装计数器 */
;;;148    			if(_tmr->Mode == TMR_AUTO_MODE)
000098  7801              LDRB     r1,[r0,#0]
00009a  2901              CMP      r1,#1
00009c  d101              BNE      |L1.162|
;;;149    			{
;;;150    				_tmr->Count = _tmr->PreLoad;
00009e  6881              LDR      r1,[r0,#8]
0000a0  6041              STR      r1,[r0,#4]
                  |L1.162|
;;;151    			}
;;;152    		}
;;;153    	}
;;;154    }
0000a2  4770              BX       lr
;;;155    
                          ENDP

                  SysTick_ISR PROC
;;;86     extern void bsp_RunPer2s(void);
;;;87     void SysTick_ISR(void)
0000a4  b510              PUSH     {r4,lr}
;;;88     {
;;;89     	static uint8_t ms_count = 0,s_count = 0;
;;;90     	uint8_t i;
;;;91     
;;;92     	/* 每隔1ms进来1次 （仅用于 bsp_DelayMS） */
;;;93     	if (s_uiDelayCount > 0)
0000a6  4890              LDR      r0,|L1.744|
0000a8  6800              LDR      r0,[r0,#0]  ; s_uiDelayCount
0000aa  b140              CBZ      r0,|L1.190|
;;;94     	{
;;;95     		if (--s_uiDelayCount == 0)
0000ac  488e              LDR      r0,|L1.744|
0000ae  6800              LDR      r0,[r0,#0]  ; s_uiDelayCount
0000b0  1e40              SUBS     r0,r0,#1
0000b2  498d              LDR      r1,|L1.744|
0000b4  6008              STR      r0,[r1,#0]  ; s_uiDelayCount
0000b6  d102              BNE      |L1.190|
;;;96     		{
;;;97     			s_ucTimeOutFlag = 1;
0000b8  2001              MOVS     r0,#1
0000ba  1d09              ADDS     r1,r1,#4
0000bc  7008              STRB     r0,[r1,#0]
                  |L1.190|
;;;98     		}
;;;99     	}
;;;100    
;;;101    	/* 每隔1ms，对软件定时器的计数器进行减一操作 */
;;;102    	for (i = 0; i < TMR_COUNT; i++)
0000be  2400              MOVS     r4,#0
0000c0  e008              B        |L1.212|
                  |L1.194|
;;;103    	{
;;;104    		bsp_SoftTimerDec(&s_tTmr[i]);
0000c2  eb040144          ADD      r1,r4,r4,LSL #1
0000c6  4a84              LDR      r2,|L1.728|
0000c8  eb020081          ADD      r0,r2,r1,LSL #2
0000cc  f7fffffe          BL       bsp_SoftTimerDec
0000d0  1c60              ADDS     r0,r4,#1              ;102
0000d2  b2c4              UXTB     r4,r0                 ;102
                  |L1.212|
0000d4  2c04              CMP      r4,#4                 ;102
0000d6  dbf4              BLT      |L1.194|
;;;105    	}
;;;106    
;;;107    	/* 全局运行时间每1ms增1 */
;;;108    	g_iRunTime++;
0000d8  4884              LDR      r0,|L1.748|
0000da  6800              LDR      r0,[r0,#0]  ; g_iRunTime
0000dc  1c40              ADDS     r0,r0,#1
0000de  4983              LDR      r1,|L1.748|
0000e0  6008              STR      r0,[r1,#0]  ; g_iRunTime
;;;109    	if (g_iRunTime == 0x7FFFFFFF)	/* 这个变量是 int32_t 类型，最大数为 0x7FFFFFFF */
0000e2  4608              MOV      r0,r1
0000e4  6800              LDR      r0,[r0,#0]  ; g_iRunTime
0000e6  f06f4100          MVN      r1,#0x80000000
0000ea  4288              CMP      r0,r1
0000ec  d102              BNE      |L1.244|
;;;110    	{
;;;111    		g_iRunTime = 0;
0000ee  2000              MOVS     r0,#0
0000f0  497e              LDR      r1,|L1.748|
0000f2  6008              STR      r0,[r1,#0]  ; g_iRunTime
                  |L1.244|
;;;112    	}
;;;113    
;;;114    	bsp_RunPer1ms();		/* 每隔1ms调用一次此函数，此函数在 bsp.c */
0000f4  f7fffffe          BL       bsp_RunPer1ms
;;;115    
;;;116    	if (++ms_count >= 10)
0000f8  487b              LDR      r0,|L1.744|
0000fa  300c              ADDS     r0,r0,#0xc
0000fc  7800              LDRB     r0,[r0,#0]  ; ms_count
0000fe  1c40              ADDS     r0,r0,#1
000100  b2c0              UXTB     r0,r0
000102  4979              LDR      r1,|L1.744|
000104  310c              ADDS     r1,r1,#0xc
000106  7008              STRB     r0,[r1,#0]
000108  280a              CMP      r0,#0xa
00010a  db13              BLT      |L1.308|
;;;117    	{
;;;118    		ms_count = 0;
00010c  2000              MOVS     r0,#0
00010e  7008              STRB     r0,[r1,#0]
;;;119    
;;;120    		bsp_RunPer10ms();	/* 每隔10ms调用一次此函数，此函数在 bsp.c */
000110  f7fffffe          BL       bsp_RunPer10ms
;;;121    		
;;;122    		if(++s_count>100)
000114  4874              LDR      r0,|L1.744|
000116  300d              ADDS     r0,r0,#0xd
000118  7800              LDRB     r0,[r0,#0]  ; s_count
00011a  1c40              ADDS     r0,r0,#1
00011c  b2c0              UXTB     r0,r0
00011e  4972              LDR      r1,|L1.744|
000120  310d              ADDS     r1,r1,#0xd
000122  7008              STRB     r0,[r1,#0]
000124  2864              CMP      r0,#0x64
000126  dd05              BLE      |L1.308|
;;;123    		{
;;;124    			bsp_RunPer2s();	/* 每隔10ms调用一次此函数，此函数在 bsp.c */
000128  f7fffffe          BL       bsp_RunPer2s
;;;125    			s_count = 0;
00012c  2000              MOVS     r0,#0
00012e  496e              LDR      r1,|L1.744|
000130  310d              ADDS     r1,r1,#0xd
000132  7008              STRB     r0,[r1,#0]
                  |L1.308|
;;;126    		}
;;;127    	}
;;;128    }
000134  bd10              POP      {r4,pc}
;;;129    
                          ENDP

                  bsp_DelayMS PROC
;;;163    */
;;;164    void bsp_DelayMS(uint32_t n)
000136  b510              PUSH     {r4,lr}
;;;165    {
000138  4604              MOV      r4,r0
;;;166    	if (n == 0)
00013a  b904              CBNZ     r4,|L1.318|
                  |L1.316|
;;;167    	{
;;;168    		return;
;;;169    	}
;;;170    	else if (n == 1)
;;;171    	{
;;;172    		n = 2;
;;;173    	}
;;;174    
;;;175    	DISABLE_INT();  			/* 关中断 */
;;;176    
;;;177    	s_uiDelayCount = n;
;;;178    	s_ucTimeOutFlag = 0;
;;;179    
;;;180    	ENABLE_INT();  				/* 开中断 */
;;;181    
;;;182    	while (1)
;;;183    	{
;;;184    		bsp_Idle();				/* CPU空闲执行的操作， 见 bsp.c 和 bsp.h 文件 */
;;;185    
;;;186    		/*
;;;187    			等待延迟时间到
;;;188    			注意：编译器认为 s_ucTimeOutFlag = 0，所以可能优化错误，因此 s_ucTimeOutFlag 变量必须申明为 volatile
;;;189    		*/
;;;190    		if (s_ucTimeOutFlag == 1)
;;;191    		{
;;;192    			break;
;;;193    		}
;;;194    	}
;;;195    }
00013c  bd10              POP      {r4,pc}
                  |L1.318|
00013e  2c01              CMP      r4,#1                 ;170
000140  d100              BNE      |L1.324|
000142  2402              MOVS     r4,#2                 ;172
                  |L1.324|
000144  2001              MOVS     r0,#1                 ;175
000146  f7fffffe          BL       __set_PRIMASK
00014a  4867              LDR      r0,|L1.744|
00014c  6004              STR      r4,[r0,#0]            ;177  ; s_uiDelayCount
00014e  2000              MOVS     r0,#0                 ;178
000150  4965              LDR      r1,|L1.744|
000152  1d09              ADDS     r1,r1,#4              ;178
000154  7008              STRB     r0,[r1,#0]            ;178
000156  f7fffffe          BL       __set_PRIMASK
00015a  e007              B        |L1.364|
                  |L1.348|
00015c  f7fffffe          BL       bsp_Idle
000160  4861              LDR      r0,|L1.744|
000162  1d00              ADDS     r0,r0,#4              ;190
000164  7800              LDRB     r0,[r0,#0]            ;190  ; s_ucTimeOutFlag
000166  2801              CMP      r0,#1                 ;190
000168  d100              BNE      |L1.364|
00016a  e000              B        |L1.366|
                  |L1.364|
00016c  e7f6              B        |L1.348|
                  |L1.366|
00016e  bf00              NOP                            ;192
000170  e7e4              B        |L1.316|
;;;196    
                          ENDP

                  bsp_DelayUS PROC
;;;204    */
;;;205    void bsp_DelayUS(uint32_t n)
000172  b5f0              PUSH     {r4-r7,lr}
;;;206    {
;;;207        uint32_t ticks;
;;;208        uint32_t told;
;;;209        uint32_t tnow;
;;;210        uint32_t tcnt = 0;
000174  2400              MOVS     r4,#0
;;;211        uint32_t reload;
;;;212           
;;;213    	reload = SysTick->LOAD;                
000176  f04f26e0          MOV      r6,#0xe000e000
00017a  6975              LDR      r5,[r6,#0x14]
;;;214        ticks = n * (SystemCoreClock / 1000000);	 /* 需要的节拍数 */  
00017c  4e57              LDR      r6,|L1.732|
00017e  6836              LDR      r6,[r6,#0]  ; SystemCoreClock
000180  4f5b              LDR      r7,|L1.752|
000182  fbb6f6f7          UDIV     r6,r6,r7
000186  fb06f100          MUL      r1,r6,r0
;;;215        
;;;216        tcnt = 0;
00018a  bf00              NOP      
;;;217        told = SysTick->VAL;             /* 刚进入时的计数器值 */
00018c  f04f26e0          MOV      r6,#0xe000e000
000190  69b2              LDR      r2,[r6,#0x18]
;;;218    
;;;219        while (1)
000192  e010              B        |L1.438|
                  |L1.404|
;;;220        {
;;;221            tnow = SysTick->VAL;    
000194  f04f26e0          MOV      r6,#0xe000e000
000198  69b3              LDR      r3,[r6,#0x18]
;;;222            if (tnow != told)
00019a  4293              CMP      r3,r2
00019c  d00b              BEQ      |L1.438|
;;;223            {    
;;;224                /* SYSTICK是一个递减的计数器 */    
;;;225                if (tnow < told)
00019e  4293              CMP      r3,r2
0001a0  d202              BCS      |L1.424|
;;;226                {
;;;227                    tcnt += told - tnow;    
0001a2  1ad6              SUBS     r6,r2,r3
0001a4  4434              ADD      r4,r4,r6
0001a6  e002              B        |L1.430|
                  |L1.424|
;;;228                }
;;;229                /* 重新装载递减 */
;;;230                else
;;;231                {
;;;232                    tcnt += reload - tnow + told;    
0001a8  1aee              SUBS     r6,r5,r3
0001aa  4416              ADD      r6,r6,r2
0001ac  4434              ADD      r4,r4,r6
                  |L1.430|
;;;233                }        
;;;234                told = tnow;
0001ae  461a              MOV      r2,r3
;;;235    
;;;236                /* 时间超过/等于要延迟的时间,则退出 */
;;;237                if (tcnt >= ticks)
0001b0  428c              CMP      r4,r1
0001b2  d300              BCC      |L1.438|
;;;238                {
;;;239                	break;
0001b4  e000              B        |L1.440|
                  |L1.438|
0001b6  e7ed              B        |L1.404|
                  |L1.440|
0001b8  bf00              NOP      
;;;240                }
;;;241            }  
;;;242        }
;;;243    } 
0001ba  bdf0              POP      {r4-r7,pc}
;;;244    
                          ENDP

                  bsp_StartTimer PROC
;;;254    */
;;;255    void bsp_StartTimer(uint8_t _id, uint32_t _period)
0001bc  b570              PUSH     {r4-r6,lr}
;;;256    {
0001be  4605              MOV      r5,r0
0001c0  460c              MOV      r4,r1
;;;257    	if (_id >= TMR_COUNT)
0001c2  2d04              CMP      r5,#4
0001c4  db01              BLT      |L1.458|
;;;258    	{
;;;259    		/* 打印出错的源代码文件名、函数名称 */
;;;260    		//BSP_Printf("Error: file %s, function %s()\r\n", __FILE__, __FUNCTION__);
;;;261    		while(1); /* 参数异常，死机等待看门狗复位 */
0001c6  bf00              NOP      
                  |L1.456|
0001c8  e7fe              B        |L1.456|
                  |L1.458|
;;;262    	}
;;;263    
;;;264    	DISABLE_INT();  			/* 关中断 */
0001ca  2001              MOVS     r0,#1
0001cc  f7fffffe          BL       __set_PRIMASK
;;;265    
;;;266    	s_tTmr[_id].Count = _period;		/* 实时计数器初值 */
0001d0  eb050045          ADD      r0,r5,r5,LSL #1
0001d4  4940              LDR      r1,|L1.728|
0001d6  eb010080          ADD      r0,r1,r0,LSL #2
0001da  6044              STR      r4,[r0,#4]
;;;267    	s_tTmr[_id].PreLoad = _period;		/* 计数器自动重装值，仅自动模式起作用 */
0001dc  eb050045          ADD      r0,r5,r5,LSL #1
0001e0  eb010080          ADD      r0,r1,r0,LSL #2
0001e4  6084              STR      r4,[r0,#8]
;;;268    	s_tTmr[_id].Flag = 0;				/* 定时时间到标志 */
0001e6  2000              MOVS     r0,#0
0001e8  eb050145          ADD      r1,r5,r5,LSL #1
0001ec  4a3a              LDR      r2,|L1.728|
0001ee  eb020181          ADD      r1,r2,r1,LSL #2
0001f2  7048              STRB     r0,[r1,#1]
;;;269    	s_tTmr[_id].Mode = TMR_ONCE_MODE;	/* 1次性工作模式 */
0001f4  eb050145          ADD      r1,r5,r5,LSL #1
0001f8  f8020021          STRB     r0,[r2,r1,LSL #2]
;;;270    
;;;271    	ENABLE_INT();  				/* 开中断 */
0001fc  f7fffffe          BL       __set_PRIMASK
;;;272    }
000200  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP

                  bsp_StartAutoTimer PROC
;;;282    */
;;;283    void bsp_StartAutoTimer(uint8_t _id, uint32_t _period)
000202  b570              PUSH     {r4-r6,lr}
;;;284    {
000204  4605              MOV      r5,r0
000206  460c              MOV      r4,r1
;;;285    	if (_id >= TMR_COUNT)
000208  2d04              CMP      r5,#4
00020a  db01              BLT      |L1.528|
;;;286    	{
;;;287    		/* 打印出错的源代码文件名、函数名称 */
;;;288    		//BSP_Printf("Error: file %s, function %s()\r\n", __FILE__, __FUNCTION__);
;;;289    		while(1); /* 参数异常，死机等待看门狗复位 */
00020c  bf00              NOP      
                  |L1.526|
00020e  e7fe              B        |L1.526|
                  |L1.528|
;;;290    	}
;;;291    
;;;292    	DISABLE_INT();  		/* 关中断 */
000210  2001              MOVS     r0,#1
000212  f7fffffe          BL       __set_PRIMASK
;;;293    
;;;294    	s_tTmr[_id].Count = _period;			/* 实时计数器初值 */
000216  eb050045          ADD      r0,r5,r5,LSL #1
00021a  492f              LDR      r1,|L1.728|
00021c  eb010080          ADD      r0,r1,r0,LSL #2
000220  6044              STR      r4,[r0,#4]
;;;295    	s_tTmr[_id].PreLoad = _period;		/* 计数器自动重装值，仅自动模式起作用 */
000222  eb050045          ADD      r0,r5,r5,LSL #1
000226  eb010080          ADD      r0,r1,r0,LSL #2
00022a  6084              STR      r4,[r0,#8]
;;;296    	s_tTmr[_id].Flag = 0;				/* 定时时间到标志 */
00022c  2000              MOVS     r0,#0
00022e  eb050145          ADD      r1,r5,r5,LSL #1
000232  4a29              LDR      r2,|L1.728|
000234  eb020181          ADD      r1,r2,r1,LSL #2
000238  7048              STRB     r0,[r1,#1]
;;;297    	s_tTmr[_id].Mode = TMR_AUTO_MODE;	/* 自动工作模式 */
00023a  2001              MOVS     r0,#1
00023c  eb050145          ADD      r1,r5,r5,LSL #1
000240  f8020021          STRB     r0,[r2,r1,LSL #2]
;;;298    
;;;299    	ENABLE_INT();  			/* 开中断 */
000244  2000              MOVS     r0,#0
000246  f7fffffe          BL       __set_PRIMASK
;;;300    }
00024a  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP

                  bsp_StopTimer PROC
;;;309    */
;;;310    void bsp_StopTimer(uint8_t _id)
00024c  b510              PUSH     {r4,lr}
;;;311    {
00024e  4604              MOV      r4,r0
;;;312    	if (_id >= TMR_COUNT)
000250  2c04              CMP      r4,#4
000252  db01              BLT      |L1.600|
;;;313    	{
;;;314    		/* 打印出错的源代码文件名、函数名称 */
;;;315    		//BSP_Printf("Error: file %s, function %s()\r\n", __FILE__, __FUNCTION__);
;;;316    		while(1); /* 参数异常，死机等待看门狗复位 */
000254  bf00              NOP      
                  |L1.598|
000256  e7fe              B        |L1.598|
                  |L1.600|
;;;317    	}
;;;318    
;;;319    	DISABLE_INT();  	/* 关中断 */
000258  2001              MOVS     r0,#1
00025a  f7fffffe          BL       __set_PRIMASK
;;;320    
;;;321    	s_tTmr[_id].Count = 0;				/* 实时计数器初值 */
00025e  2000              MOVS     r0,#0
000260  eb040144          ADD      r1,r4,r4,LSL #1
000264  4a1c              LDR      r2,|L1.728|
000266  eb020181          ADD      r1,r2,r1,LSL #2
00026a  6048              STR      r0,[r1,#4]
;;;322    	s_tTmr[_id].Flag = 0;				/* 定时时间到标志 */
00026c  eb040144          ADD      r1,r4,r4,LSL #1
000270  eb020181          ADD      r1,r2,r1,LSL #2
000274  7048              STRB     r0,[r1,#1]
;;;323    	s_tTmr[_id].Mode = TMR_ONCE_MODE;	/* 自动工作模式 */
000276  eb040144          ADD      r1,r4,r4,LSL #1
00027a  f8020021          STRB     r0,[r2,r1,LSL #2]
;;;324    
;;;325    	ENABLE_INT();  		/* 开中断 */
00027e  f7fffffe          BL       __set_PRIMASK
;;;326    }
000282  bd10              POP      {r4,pc}
;;;327    
                          ENDP

                  bsp_CheckTimer PROC
;;;336    */
;;;337    uint8_t bsp_CheckTimer(uint8_t _id)
000284  4601              MOV      r1,r0
;;;338    {
;;;339    	if (_id >= TMR_COUNT)
000286  2904              CMP      r1,#4
000288  db01              BLT      |L1.654|
;;;340    	{
;;;341    		return 0;
00028a  2000              MOVS     r0,#0
                  |L1.652|
;;;342    	}
;;;343    
;;;344    	if (s_tTmr[_id].Flag == 1)
;;;345    	{
;;;346    		s_tTmr[_id].Flag = 0;
;;;347    		return 1;
;;;348    	}
;;;349    	else
;;;350    	{
;;;351    		return 0;
;;;352    	}
;;;353    }
00028c  4770              BX       lr
                  |L1.654|
00028e  eb010041          ADD      r0,r1,r1,LSL #1       ;344
000292  4a11              LDR      r2,|L1.728|
000294  eb020080          ADD      r0,r2,r0,LSL #2       ;344
000298  7840              LDRB     r0,[r0,#1]            ;344
00029a  2801              CMP      r0,#1                 ;344
00029c  d108              BNE      |L1.688|
00029e  2000              MOVS     r0,#0                 ;346
0002a0  eb010241          ADD      r2,r1,r1,LSL #1       ;346
0002a4  4b0c              LDR      r3,|L1.728|
0002a6  eb030282          ADD      r2,r3,r2,LSL #2       ;346
0002aa  7050              STRB     r0,[r2,#1]            ;346
0002ac  2001              MOVS     r0,#1                 ;347
0002ae  e7ed              B        |L1.652|
                  |L1.688|
0002b0  2000              MOVS     r0,#0                 ;351
0002b2  e7eb              B        |L1.652|
;;;354    
                          ENDP

                  bsp_GetRunTime PROC
;;;362    */
;;;363    int32_t bsp_GetRunTime(void)
0002b4  b510              PUSH     {r4,lr}
;;;364    {
;;;365    	int32_t runtime;
;;;366    
;;;367    	DISABLE_INT();  	/* 关中断 */
0002b6  2001              MOVS     r0,#1
0002b8  f7fffffe          BL       __set_PRIMASK
;;;368    
;;;369    	runtime = g_iRunTime;	/* 这个变量在Systick中断中被改写，因此需要关中断进行保护 */
0002bc  480b              LDR      r0,|L1.748|
0002be  6804              LDR      r4,[r0,#0]  ; g_iRunTime
;;;370    
;;;371    	ENABLE_INT();  		/* 开中断 */
0002c0  2000              MOVS     r0,#0
0002c2  f7fffffe          BL       __set_PRIMASK
;;;372    
;;;373    	return runtime;
0002c6  4620              MOV      r0,r4
;;;374    }
0002c8  bd10              POP      {r4,pc}
;;;375    
                          ENDP

                  SysTick_Handler PROC
;;;383    */
;;;384    void SysTick_Handler(void)
0002ca  b510              PUSH     {r4,lr}
;;;385    {
;;;386    	SysTick_ISR();
0002cc  f7fffffe          BL       SysTick_ISR
;;;387    }
0002d0  bd10              POP      {r4,pc}
;;;388    
                          ENDP

                  __set_PRIMASK PROC
;;;986     */
;;;987    static __INLINE void __set_PRIMASK(uint32_t priMask)
0002d2  f3808810          MSR      PRIMASK,r0
;;;988    {
;;;989      register uint32_t __regPriMask         __ASM("primask");
;;;990      __regPriMask = (priMask);
;;;991    }
0002d6  4770              BX       lr
;;;992    
                          ENDP

                  |L1.728|
                          DCD      ||.bss||
                  |L1.732|
                          DCD      SystemCoreClock
                  |L1.736|
                          DCD      0xe000ed18
                  |L1.740|
                          DCD      0xe000e400
                  |L1.744|
                          DCD      ||.data||
                  |L1.748|
                          DCD      g_iRunTime
                  |L1.752|
                          DCD      0x000f4240

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tTmr
                          %        48

                          AREA ||.data||, DATA, ALIGN=2

                  s_uiDelayCount
                          DCD      0x00000000
                  s_ucTimeOutFlag
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  g_iRunTime
                          DCD      0x00000000
                  ms_count
00000c  00                DCB      0x00
                  s_count
00000d  00                DCB      0x00
