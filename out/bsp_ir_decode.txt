; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\out\bsp_ir_decode.o --depend=.\out\bsp_ir_decode.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\ARM\INC -ID:\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\out\bsp_ir_decode.crf user\src\bsp_ir_decode.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  bsp_InitIRD PROC
;;;39     */
;;;40     void bsp_InitIRD(void)
000000  b508              PUSH     {r3,lr}
;;;41     {
;;;42     	GPIO_InitTypeDef GPIO_InitStructure;
;;;43     
;;;44     	/* 打开GPIO时钟 */
;;;45     	RCC_APB2PeriphClockCmd(RCC_IRD, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;46     
;;;47     	/* 配置DQ为输入引脚 */
;;;48     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		/* 设为输出口 */
00000a  2004              MOVS     r0,#4
00000c  f88d0003          STRB     r0,[sp,#3]
;;;49     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;50     	GPIO_InitStructure.GPIO_Pin = PIN_IRD;
000016  f44f7080          MOV      r0,#0x100
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;51     	GPIO_Init(PORT_IRD, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4885              LDR      r0,|L1.568|
000022  f7fffffe          BL       GPIO_Init
;;;52     }
000026  bd08              POP      {r3,pc}
;;;53     
                          ENDP

                  IRD_StartWork PROC
;;;61     */
;;;62     void IRD_StartWork(void)
000028  b500              PUSH     {lr}
;;;63     {
00002a  b087              SUB      sp,sp,#0x1c
;;;64     	TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;65     	NVIC_InitTypeDef NVIC_InitStructure;
;;;66     	TIM_TimeBaseInitTypeDef TIM_TimeBase;
;;;67     //  TIM_OCInitTypeDef  TIM_OCInitStructure;	
;;;68     	TIM_DeInit(TIM1);
00002c  4883              LDR      r0,|L1.572|
00002e  f7fffffe          BL       TIM_DeInit
;;;69     	
;;;70     	TIM_TimeBase.TIM_Period=65535;
000032  f64f70ff          MOV      r0,#0xffff
000036  f8ad0004          STRH     r0,[sp,#4]
;;;71     	TIM_TimeBase.TIM_Prescaler=639;
00003a  f240207f          MOV      r0,#0x27f
00003e  f8ad0000          STRH     r0,[sp,#0]
;;;72     	TIM_TimeBase.TIM_ClockDivision = TIM_CKD_DIV1;  
000042  2000              MOVS     r0,#0
000044  f8ad0006          STRH     r0,[sp,#6]
;;;73     	TIM_TimeBase.TIM_CounterMode = TIM_CounterMode_Up;
000048  f8ad0002          STRH     r0,[sp,#2]
;;;74     	TIM_TimeBaseInit(TIM1,&TIM_TimeBase);
00004c  4669              MOV      r1,sp
00004e  487b              LDR      r0,|L1.572|
000050  f7fffffe          BL       TIM_TimeBaseInit
;;;75     	
;;;76     	/* TIM1 clock enable */
;;;77     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
000054  2101              MOVS     r1,#1
000056  02c8              LSLS     r0,r1,#11
000058  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;78     
;;;79     // 	  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;                           //???PWM??1  
;;;80     //     TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;                
;;;81     //     TIM_OCInitStructure.TIM_Pulse = 50;                                       //?????,???????????,??????  
;;;82     //     TIM_OCInitStructure.TIM_OCPolarity =TIM_OCPolarity_High;                    //?????????CCR1?????  
;;;83     //     TIM_OC1Init(TIM1, &TIM_OCInitStructure);                                    //????1      
;;;84     //     TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
;;;85     
;;;86     
;;;87     	/* TIM1 chennel1 configuration : PA.8 */
;;;88       bsp_InitIRD();
00005c  f7fffffe          BL       bsp_InitIRD
;;;89     
;;;90     	/* Enable the TIM1 global Interrupt */
;;;91     	NVIC_InitStructure.NVIC_IRQChannel = TIM1_CC_IRQn;
000060  201b              MOVS     r0,#0x1b
000062  f88d000c          STRB     r0,[sp,#0xc]
;;;92     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000066  2000              MOVS     r0,#0
000068  f88d000d          STRB     r0,[sp,#0xd]
;;;93     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00006c  2001              MOVS     r0,#1
00006e  f88d000e          STRB     r0,[sp,#0xe]
;;;94     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000072  f88d000f          STRB     r0,[sp,#0xf]
;;;95     	NVIC_Init(&NVIC_InitStructure);
000076  a803              ADD      r0,sp,#0xc
000078  f7fffffe          BL       NVIC_Init
;;;96     
;;;97     	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
00007c  2000              MOVS     r0,#0
00007e  f8ad0010          STRH     r0,[sp,#0x10]
;;;98     	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_BothEdge;
000082  200a              MOVS     r0,#0xa
000084  f8ad0012          STRH     r0,[sp,#0x12]
;;;99     	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
000088  2001              MOVS     r0,#1
00008a  f8ad0014          STRH     r0,[sp,#0x14]
;;;100    	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
00008e  2000              MOVS     r0,#0
000090  f8ad0016          STRH     r0,[sp,#0x16]
;;;101    	TIM_ICInitStructure.TIM_ICFilter = 0x7;
000094  2007              MOVS     r0,#7
000096  f8ad0018          STRH     r0,[sp,#0x18]
;;;102    	
;;;103    	TIM_ICInit(TIM1, &TIM_ICInitStructure);
00009a  a904              ADD      r1,sp,#0x10
00009c  4867              LDR      r0,|L1.572|
00009e  f7fffffe          BL       TIM_ICInit
;;;104    	
;;;105    	/* 设置分频为 1680/2， 捕获计数器值的单位正好是 10us, 方便脉宽比较 */
;;;106      //TIM_PrescalerConfig(TIM1, 639, TIM_PSCReloadMode_Immediate);
;;;107    	
;;;108    	/* TIM enable counter */
;;;109    	TIM_Cmd(TIM1, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  4865              LDR      r0,|L1.572|
0000a6  f7fffffe          BL       TIM_Cmd
;;;110    
;;;111    	/* Enable the CC3 Interrupt Request */
;;;112    	TIM_ITConfig(TIM1, TIM_IT_CC1, ENABLE);
0000aa  2201              MOVS     r2,#1
0000ac  2102              MOVS     r1,#2
0000ae  4863              LDR      r0,|L1.572|
0000b0  f7fffffe          BL       TIM_ITConfig
;;;113    	//TIM_CtrlPWMOutputs(TIM1,ENABLE);
;;;114    	g_tIR.LastCapture = 0;	
0000b4  2000              MOVS     r0,#0
0000b6  4962              LDR      r1,|L1.576|
0000b8  8008              STRH     r0,[r1,#0]
;;;115    	g_tIR.Status = 0;
0000ba  7088              STRB     r0,[r1,#2]
;;;116    }
0000bc  b007              ADD      sp,sp,#0x1c
0000be  bd00              POP      {pc}
;;;117    
                          ENDP

                  IRD_StopWork PROC
;;;125    */
;;;126    void IRD_StopWork(void)
0000c0  b510              PUSH     {r4,lr}
;;;127    {
;;;128    	TIM_Cmd(TIM1, DISABLE);
0000c2  2100              MOVS     r1,#0
0000c4  485d              LDR      r0,|L1.572|
0000c6  f7fffffe          BL       TIM_Cmd
;;;129    	
;;;130    	TIM_ITConfig(TIM1, TIM_IT_CC1, DISABLE);	
0000ca  2200              MOVS     r2,#0
0000cc  2102              MOVS     r1,#2
0000ce  485b              LDR      r0,|L1.572|
0000d0  f7fffffe          BL       TIM_ITConfig
;;;131    }
0000d4  bd10              POP      {r4,pc}
;;;132    
                          ENDP

                  IRD_DecodeNec PROC
;;;141    //uint16_t width_lenth[50]= {0};
;;;142    void IRD_DecodeNec(uint16_t _width)
0000d6  b570              PUSH     {r4-r6,lr}
;;;143    {
0000d8  4604              MOV      r4,r0
;;;144    	static uint16_t s_LowWidth;
;;;145    	static uint8_t s_Byte;
;;;146    	static uint8_t s_Bit;
;;;147    	
;;;148    //	static uint8_t width_conut = 0;
;;;149    	uint16_t TotalWitdh;
;;;150    	
;;;151    	/* NEC 格式 （5段）
;;;152    		1、引导码  9ms低 + 4.5ms高
;;;153    		2、低8位地址码  0=1.125ms  1=2.25ms    bit0先传
;;;154    		3、高8位地址码  0=1.125ms  1=2.25ms
;;;155    		4、8位数据      0=1.125ms  1=2.25ms
;;;156    		5、8为数码反码  0=1.125ms  1=2.25ms
;;;157    	*/
;;;158    // //width_lenth[width_conut] = _width;
;;;159    // 	width_conut++;
;;;160    loop1:	
0000da  bf00              NOP      
                  |L1.220|
;;;161    	switch (g_tIR.Status)
0000dc  4858              LDR      r0,|L1.576|
0000de  7880              LDRB     r0,[r0,#2]  ; g_tIR
0000e0  b110              CBZ      r0,|L1.232|
0000e2  2801              CMP      r0,#1
0000e4  d175              BNE      |L1.466|
0000e6  e00f              B        |L1.264|
                  |L1.232|
;;;162    	{
;;;163    		case 0:			/* 929 等待引导码低信号  7ms - 11ms */
;;;164    			if ((_width > 1300) && (_width < 1400))
0000e8  f2405014          MOV      r0,#0x514
0000ec  4284              CMP      r4,r0
0000ee  dd0a              BLE      |L1.262|
0000f0  f5b46faf          CMP      r4,#0x578
0000f4  da07              BGE      |L1.262|
;;;165    			{
;;;166    				g_tIR.Status = 1;
0000f6  2001              MOVS     r0,#1
0000f8  4951              LDR      r1,|L1.576|
0000fa  7088              STRB     r0,[r1,#2]
;;;167    				s_Byte = 0;
0000fc  2000              MOVS     r0,#0
0000fe  4951              LDR      r1,|L1.580|
000100  7008              STRB     r0,[r1,#0]
;;;168    				s_Bit = 0;
000102  1c49              ADDS     r1,r1,#1
000104  7008              STRB     r0,[r1,#0]
                  |L1.262|
;;;169    			}
;;;170    			break;
000106  e064              B        |L1.466|
                  |L1.264|
;;;171    
;;;172    // 		case 1:			/* 413 判断引导码高信号  3ms - 6ms */
;;;173    // 			if ((_width > 313) && (_width < 600))	/* 引导码 4.5ms */
;;;174    // 			{
;;;175    // 				g_tIR.Status = 2;
;;;176    // 			}
;;;177    // 			else if ((_width > 150) && (_width < 250))	/* 2.25ms */
;;;178    // 			{
;;;179    // 				#ifdef IR_REPEAT_SEND_EN				
;;;180    // 					if (g_tIR.RepeatCount >= IR_REPEAT_FILTER)
;;;181    // 					{
;;;182    // 						bsp_PutKey(g_tIR.RxBuf[2] + IR_KEY_STRAT);	/* 连发码 */
;;;183    // 					}
;;;184    // 					else
;;;185    // 					{
;;;186    // 						g_tIR.RepeatCount++;
;;;187    // 					}
;;;188    // 				#endif
;;;189    // 				g_tIR.Status = 0;	/* 复位解码状态 */
;;;190    // 			}
;;;191    // 			else
;;;192    // 			{
;;;193    // 				/* 异常脉宽 */
;;;194    // 				g_tIR.Status = 0;	/* 复位解码状态 */
;;;195    // 			}
;;;196    // 			break;
;;;197    		
;;;198    // 		case 2:			/* 低电平期间 0.56ms */
;;;199    // 			if ((_width > 10) && (_width < 100))
;;;200    // 			{		
;;;201    // 				g_tIR.Status = 3;
;;;202    // 				s_LowWidth = _width;	/* 保存低电平宽度 */
;;;203    // 			}
;;;204    // 			else	/* 异常脉宽 */
;;;205    // 			{
;;;206    // 				/* 异常脉宽 */
;;;207    // 				g_tIR.Status = 0;	/* 复位解码器状态 */	
;;;208    // 				goto loop1;		/* 继续判断同步信号 */
;;;209    // 			}
;;;210    // 			break;
;;;211    
;;;212    		case 1:			/* 85+25, 64+157 开始连续解码32bit */						
;;;213    			TotalWitdh =  _width;
000108  4625              MOV      r5,r4
;;;214    			/* 0的宽度为1.125ms，1的宽度为2.25ms */				
;;;215    			s_Byte >>= 1;
00010a  484e              LDR      r0,|L1.580|
00010c  7800              LDRB     r0,[r0,#0]  ; s_Byte
00010e  1040              ASRS     r0,r0,#1
000110  494c              LDR      r1,|L1.580|
000112  7008              STRB     r0,[r1,#0]
;;;216    			if ((TotalWitdh > 92) && (TotalWitdh < 132))
000114  462c              MOV      r4,r5
000116  2d5c              CMP      r5,#0x5c
000118  dd01              BLE      |L1.286|
00011a  2d84              CMP      r5,#0x84
00011c  db0d              BLT      |L1.314|
                  |L1.286|
;;;217    			{
;;;218    				;					/* bit = 0 */
;;;219    			}
;;;220    			else if ((TotalWitdh > 205) && (TotalWitdh < 245))
00011e  2dcd              CMP      r5,#0xcd
000120  dd07              BLE      |L1.306|
000122  2df5              CMP      r5,#0xf5
000124  da05              BGE      |L1.306|
;;;221    			{
;;;222    				s_Byte += 0x80;		/* bit = 1 */
000126  4847              LDR      r0,|L1.580|
000128  7800              LDRB     r0,[r0,#0]  ; s_Byte
00012a  3080              ADDS     r0,r0,#0x80
00012c  4945              LDR      r1,|L1.580|
00012e  7008              STRB     r0,[r1,#0]
000130  e003              B        |L1.314|
                  |L1.306|
;;;223    			}	
;;;224    			else
;;;225    			{
;;;226    				/* 异常脉宽 */
;;;227    				g_tIR.Status = 0;	/* 复位解码器状态 */	
000132  2000              MOVS     r0,#0
000134  4942              LDR      r1,|L1.576|
000136  7088              STRB     r0,[r1,#2]
;;;228    				goto loop1;		/* 继续判断同步信号 */
000138  e7d0              B        |L1.220|
                  |L1.314|
;;;229    			}
;;;230    			
;;;231    			s_Bit++;
00013a  4842              LDR      r0,|L1.580|
00013c  1c40              ADDS     r0,r0,#1
00013e  7800              LDRB     r0,[r0,#0]  ; s_Bit
000140  1c40              ADDS     r0,r0,#1
000142  4940              LDR      r1,|L1.580|
000144  1c49              ADDS     r1,r1,#1
000146  7008              STRB     r0,[r1,#0]
;;;232    			if (s_Bit == 8)	/* 收齐8位 */
000148  4608              MOV      r0,r1
00014a  7800              LDRB     r0,[r0,#0]  ; s_Bit
00014c  2808              CMP      r0,#8
00014e  d107              BNE      |L1.352|
;;;233    			{
;;;234    				g_tIR.RxBuf[0] = s_Byte;
000150  1e48              SUBS     r0,r1,#1
000152  7800              LDRB     r0,[r0,#0]  ; s_Byte
000154  493a              LDR      r1,|L1.576|
000156  70c8              STRB     r0,[r1,#3]
;;;235    				s_Byte = 0;
000158  2000              MOVS     r0,#0
00015a  493a              LDR      r1,|L1.580|
00015c  7008              STRB     r0,[r1,#0]
00015e  e034              B        |L1.458|
                  |L1.352|
;;;236    			}
;;;237    			else if (s_Bit == 16)	/* 收齐16位 */
000160  4838              LDR      r0,|L1.580|
000162  1c40              ADDS     r0,r0,#1
000164  7800              LDRB     r0,[r0,#0]  ; s_Bit
000166  2810              CMP      r0,#0x10
000168  d107              BNE      |L1.378|
;;;238    			{
;;;239    				g_tIR.RxBuf[1] = s_Byte;
00016a  4836              LDR      r0,|L1.580|
00016c  7801              LDRB     r1,[r0,#0]  ; s_Byte
00016e  4834              LDR      r0,|L1.576|
000170  7101              STRB     r1,[r0,#4]
;;;240    				s_Byte = 0;
000172  2000              MOVS     r0,#0
000174  4933              LDR      r1,|L1.580|
000176  7008              STRB     r0,[r1,#0]
000178  e027              B        |L1.458|
                  |L1.378|
;;;241    			}
;;;242    			else if (s_Bit == 24)	/* 收齐24位 */
00017a  4832              LDR      r0,|L1.580|
00017c  1c40              ADDS     r0,r0,#1
00017e  7800              LDRB     r0,[r0,#0]  ; s_Bit
000180  2818              CMP      r0,#0x18
000182  d107              BNE      |L1.404|
;;;243    			{
;;;244    				g_tIR.RxBuf[2] = s_Byte;
000184  482f              LDR      r0,|L1.580|
000186  7801              LDRB     r1,[r0,#0]  ; s_Byte
000188  482d              LDR      r0,|L1.576|
00018a  7141              STRB     r1,[r0,#5]
;;;245    				s_Byte = 0;
00018c  2000              MOVS     r0,#0
00018e  492d              LDR      r1,|L1.580|
000190  7008              STRB     r0,[r1,#0]
000192  e01a              B        |L1.458|
                  |L1.404|
;;;246    			}
;;;247    			else if (s_Bit == 32)	/* 收齐32位 */
000194  482b              LDR      r0,|L1.580|
000196  1c40              ADDS     r0,r0,#1
000198  7800              LDRB     r0,[r0,#0]  ; s_Bit
00019a  2820              CMP      r0,#0x20
00019c  d115              BNE      |L1.458|
;;;248    			{
;;;249    				g_tIR.RxBuf[3] = s_Byte;
00019e  4829              LDR      r0,|L1.580|
0001a0  7801              LDRB     r1,[r0,#0]  ; s_Byte
0001a2  4827              LDR      r0,|L1.576|
0001a4  7181              STRB     r1,[r0,#6]
;;;250    								
;;;251    				if (g_tIR.RxBuf[2] + g_tIR.RxBuf[3] == 255)	/* 检查校验 */
0001a6  7941              LDRB     r1,[r0,#5]
0001a8  7980              LDRB     r0,[r0,#6]
0001aa  4408              ADD      r0,r0,r1
0001ac  28ff              CMP      r0,#0xff
0001ae  d108              BNE      |L1.450|
;;;252    				{
;;;253    					bsp_PutKey(g_tIR.RxBuf[2] + IR_KEY_STRAT);	/* 将键值放入KEY FIFO */
0001b0  4923              LDR      r1,|L1.576|
0001b2  7949              LDRB     r1,[r1,#5]
0001b4  3180              ADDS     r1,r1,#0x80
0001b6  b2c8              UXTB     r0,r1
0001b8  f7fffffe          BL       bsp_PutKey
;;;254    					
;;;255    					g_tIR.RepeatCount = 0;	/* 重发计数器 */										
0001bc  2000              MOVS     r0,#0
0001be  4920              LDR      r1,|L1.576|
0001c0  71c8              STRB     r0,[r1,#7]
                  |L1.450|
;;;256    				}
;;;257    				
;;;258    				g_tIR.Status = 0;	/* 等待下一组编码 */
0001c2  2000              MOVS     r0,#0
0001c4  491e              LDR      r1,|L1.576|
0001c6  7088              STRB     r0,[r1,#2]
;;;259    				break;
0001c8  e003              B        |L1.466|
                  |L1.458|
;;;260    			}
;;;261    			g_tIR.Status = 1;	/* 继续下一个bit */
0001ca  2001              MOVS     r0,#1
0001cc  491c              LDR      r1,|L1.576|
0001ce  7088              STRB     r0,[r1,#2]
;;;262    			break;						
0001d0  bf00              NOP      
                  |L1.466|
0001d2  bf00              NOP                            ;170
;;;263    	}
;;;264    }
0001d4  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

                  TIM1_CC_IRQHandler PROC
;;;275    //static uint16_t NowCapture_temp_count=0;
;;;276    void TIM1_CC_IRQHandler(void)
0001d6  b570              PUSH     {r4-r6,lr}
;;;277    {
;;;278    	uint16_t NowCapture;
;;;279    	uint16_t Width;
;;;280    	
;;;281    	if (TIM_GetITStatus(TIM1, TIM_IT_CC1))
0001d8  2102              MOVS     r1,#2
0001da  4818              LDR      r0,|L1.572|
0001dc  f7fffffe          BL       TIM_GetITStatus
0001e0  b340              CBZ      r0,|L1.564|
;;;282    	{
;;;283    		TIM_ClearITPendingBit(TIM1, TIM_IT_CC1);
0001e2  2102              MOVS     r1,#2
0001e4  4815              LDR      r0,|L1.572|
0001e6  f7fffffe          BL       TIM_ClearITPendingBit
;;;284    
;;;285    		NowCapture = TIM_GetCapture1(TIM1);	/* 读取捕获的计数器值，计数器值从0-65535循环计数 */
0001ea  4814              LDR      r0,|L1.572|
0001ec  f7fffffe          BL       TIM_GetCapture1
0001f0  4604              MOV      r4,r0
;;;286        //NowCapture_temp[NowCapture_temp_count++] = NowCapture;
;;;287    		if (NowCapture >= g_tIR.LastCapture)
0001f2  4813              LDR      r0,|L1.576|
0001f4  8801              LDRH     r1,[r0,#0]  ; g_tIR
0001f6  42a1              CMP      r1,r4
0001f8  dc03              BGT      |L1.514|
;;;288    		{
;;;289    			Width = NowCapture - g_tIR.LastCapture;
0001fa  8800              LDRH     r0,[r0,#0]  ; g_tIR
0001fc  1a20              SUBS     r0,r4,r0
0001fe  b285              UXTH     r5,r0
000200  e00a              B        |L1.536|
                  |L1.514|
;;;290    		}
;;;291    		else if (NowCapture < g_tIR.LastCapture)	/* 计数器抵达最大并翻转 */
000202  480f              LDR      r0,|L1.576|
000204  8800              LDRH     r0,[r0,#0]  ; g_tIR
000206  42a0              CMP      r0,r4
000208  dd06              BLE      |L1.536|
;;;292    		{
;;;293    			Width = ((0xFFFF - g_tIR.LastCapture) + NowCapture);
00020a  480d              LDR      r0,|L1.576|
00020c  8800              LDRH     r0,[r0,#0]  ; g_tIR
00020e  f64f71ff          MOV      r1,#0xffff
000212  1a08              SUBS     r0,r1,r0
000214  4420              ADD      r0,r0,r4
000216  b285              UXTH     r5,r0
                  |L1.536|
;;;294    		}			
;;;295    		
;;;296    		if ((g_tIR.Status == 0) && (g_tIR.LastCapture == 0))
000218  4809              LDR      r0,|L1.576|
00021a  7880              LDRB     r0,[r0,#2]  ; g_tIR
00021c  b928              CBNZ     r0,|L1.554|
00021e  4808              LDR      r0,|L1.576|
000220  8800              LDRH     r0,[r0,#0]  ; g_tIR
000222  b910              CBNZ     r0,|L1.554|
;;;297    		{
;;;298    			g_tIR.LastCapture = NowCapture;
000224  4806              LDR      r0,|L1.576|
000226  8004              STRH     r4,[r0,#0]
                  |L1.552|
;;;299    			return;
;;;300    		}
;;;301    				
;;;302    		g_tIR.LastCapture = NowCapture;	/* 保存当前计数器，用于下次计算差值 */
;;;303    		
;;;304    		IRD_DecodeNec(Width);		/* 解码 */		
;;;305    	}
;;;306    }
000228  bd70              POP      {r4-r6,pc}
                  |L1.554|
00022a  4805              LDR      r0,|L1.576|
00022c  8004              STRH     r4,[r0,#0]            ;302
00022e  4628              MOV      r0,r5                 ;304
000230  f7fffffe          BL       IRD_DecodeNec
                  |L1.564|
000234  e7f8              B        |L1.552|
;;;307    
                          ENDP

000236  0000              DCW      0x0000
                  |L1.568|
                          DCD      0x40010800
                  |L1.572|
                          DCD      0x40012c00
                  |L1.576|
                          DCD      g_tIR
                  |L1.580|
                          DCD      ||.data||+0x2

                          AREA ||.data||, DATA, ALIGN=1

                  s_LowWidth
000000  0000              DCB      0x00,0x00
                  s_Byte
000002  00                DCB      0x00
                  s_Bit
000003  00                DCB      0x00
                  g_tIR
                          %        8
