; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -o.\out\stm32f10x_i2c.o --depend=.\out\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\ARM\INC -ID:\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\out\stm32f10x_i2c.crf stdperiph_driver\src\stm32f10x_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;161      */
;;;162    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;163    {
000002  4604              MOV      r4,r0
;;;164      /* Check the parameters */
;;;165      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;166    
;;;167      if (I2Cx == I2C1)
000004  48f8              LDR      r0,|L1.1000|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L1.30|
;;;168      {
;;;169        /* Enable I2C1 reset state */
;;;170        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0548              LSLS     r0,r1,#21
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;171        /* Release I2C1 from reset state */
;;;172        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f44f1000          MOV      r0,#0x200000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L1.48|
                  |L1.30|
;;;173      }
;;;174      else
;;;175      {
;;;176        /* Enable I2C2 reset state */
;;;177        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0588              LSLS     r0,r1,#22
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;178        /* Release I2C2 from reset state */
;;;179        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f44f0080          MOV      r0,#0x400000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L1.48|
;;;180      }
;;;181    }
000030  bd10              POP      {r4,pc}
;;;182    
                          ENDP

                  I2C_Init PROC
;;;190      */
;;;191    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000032  e92d43f0          PUSH     {r4-r9,lr}
;;;192    {
000036  b085              SUB      sp,sp,#0x14
000038  4604              MOV      r4,r0
00003a  460d              MOV      r5,r1
;;;193      uint16_t tmpreg = 0, freqrange = 0;
00003c  2600              MOVS     r6,#0
00003e  2700              MOVS     r7,#0
;;;194      uint16_t result = 0x04;
000040  f04f0804          MOV      r8,#4
;;;195      uint32_t pclk1 = 8000000;
000044  f8df93a4          LDR      r9,|L1.1004|
;;;196      RCC_ClocksTypeDef  rcc_clocks;
;;;197      /* Check the parameters */
;;;198      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;199      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;200      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;201      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;202      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;203      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;204      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;205    
;;;206    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;207      /* Get the I2Cx CR2 value */
;;;208      tmpreg = I2Cx->CR2;
000048  88a6              LDRH     r6,[r4,#4]
;;;209      /* Clear frequency FREQ[5:0] bits */
;;;210      tmpreg &= CR2_FREQ_Reset;
00004a  f64f71c0          MOV      r1,#0xffc0
00004e  400e              ANDS     r6,r6,r1
;;;211      /* Get pclk1 frequency value */
;;;212      RCC_GetClocksFreq(&rcc_clocks);
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       RCC_GetClocksFreq
;;;213      pclk1 = rcc_clocks.PCLK1_Frequency;
000056  f8dd9008          LDR      r9,[sp,#8]
;;;214      /* Set frequency bits depending on pclk1 value */
;;;215      freqrange = (uint16_t)(pclk1 / 1000000);
00005a  48e5              LDR      r0,|L1.1008|
00005c  fbb9f0f0          UDIV     r0,r9,r0
000060  b287              UXTH     r7,r0
;;;216      tmpreg |= freqrange;
000062  433e              ORRS     r6,r6,r7
;;;217      /* Write to I2Cx CR2 */
;;;218      I2Cx->CR2 = tmpreg;
000064  80a6              STRH     r6,[r4,#4]
;;;219    
;;;220    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;221      /* Disable the selected I2C peripheral to configure TRISE */
;;;222      I2Cx->CR1 &= CR1_PE_Reset;
000066  8820              LDRH     r0,[r4,#0]
000068  f64f71fe          MOV      r1,#0xfffe
00006c  4008              ANDS     r0,r0,r1
00006e  8020              STRH     r0,[r4,#0]
;;;223      /* Reset tmpreg value */
;;;224      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;225      tmpreg = 0;
000070  2600              MOVS     r6,#0
;;;226    
;;;227      /* Configure speed in standard mode */
;;;228      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000072  49e0              LDR      r1,|L1.1012|
000074  6828              LDR      r0,[r5,#0]
000076  4288              CMP      r0,r1
000078  d80f              BHI      |L1.154|
;;;229      {
;;;230        /* Standard mode speed calculate */
;;;231        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
00007a  6828              LDR      r0,[r5,#0]
00007c  0040              LSLS     r0,r0,#1
00007e  fbb9f0f0          UDIV     r0,r9,r0
000082  fa1ff880          UXTH     r8,r0
;;;232        /* Test if CCR value is under 0x4*/
;;;233        if (result < 0x04)
000086  f1b80f04          CMP      r8,#4
00008a  da01              BGE      |L1.144|
;;;234        {
;;;235          /* Set minimum allowed value */
;;;236          result = 0x04;  
00008c  f04f0804          MOV      r8,#4
                  |L1.144|
;;;237        }
;;;238        /* Set speed value for standard mode */
;;;239        tmpreg |= result;	  
000090  ea460608          ORR      r6,r6,r8
;;;240        /* Set Maximum Rise Time for standard mode */
;;;241        I2Cx->TRISE = freqrange + 1; 
000094  1c78              ADDS     r0,r7,#1
000096  8420              STRH     r0,[r4,#0x20]
000098  e029              B        |L1.238|
                  |L1.154|
;;;242      }
;;;243      /* Configure speed in fast mode */
;;;244      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;245      {
;;;246        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
00009a  88e8              LDRH     r0,[r5,#6]
00009c  f5a0413f          SUB      r1,r0,#0xbf00
0000a0  39ff              SUBS     r1,r1,#0xff
0000a2  d107              BNE      |L1.180|
;;;247        {
;;;248          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;249          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
0000a4  6828              LDR      r0,[r5,#0]
0000a6  eb000040          ADD      r0,r0,r0,LSL #1
0000aa  fbb9f0f0          UDIV     r0,r9,r0
0000ae  fa1ff880          UXTH     r8,r0
0000b2  e00a              B        |L1.202|
                  |L1.180|
;;;250        }
;;;251        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;252        {
;;;253          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;254          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
0000b4  6828              LDR      r0,[r5,#0]
0000b6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ba  eb011000          ADD      r0,r1,r0,LSL #4
0000be  fbb9f0f0          UDIV     r0,r9,r0
0000c2  fa1ff880          UXTH     r8,r0
;;;255          /* Set DUTY bit */
;;;256          result |= I2C_DutyCycle_16_9;
0000c6  f4484880          ORR      r8,r8,#0x4000
                  |L1.202|
;;;257        }
;;;258    
;;;259        /* Test if CCR value is under 0x1*/
;;;260        if ((result & CCR_CCR_Set) == 0)
0000ca  f3c8000b          UBFX     r0,r8,#0,#12
0000ce  2800              CMP      r0,#0
0000d0  d101              BNE      |L1.214|
;;;261        {
;;;262          /* Set minimum allowed value */
;;;263          result |= (uint16_t)0x0001;  
0000d2  f0480801          ORR      r8,r8,#1
                  |L1.214|
;;;264        }
;;;265        /* Set speed value and set F/S bit for fast mode */
;;;266        tmpreg |= (uint16_t)(result | CCR_FS_Set);
0000d6  f4484000          ORR      r0,r8,#0x8000
0000da  4306              ORRS     r6,r6,r0
;;;267        /* Set Maximum Rise Time for fast mode */
;;;268        I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
0000dc  f44f7096          MOV      r0,#0x12c
0000e0  4378              MULS     r0,r7,r0
0000e2  f44f717a          MOV      r1,#0x3e8
0000e6  fb90f0f1          SDIV     r0,r0,r1
0000ea  1c40              ADDS     r0,r0,#1
0000ec  8420              STRH     r0,[r4,#0x20]
                  |L1.238|
;;;269      }
;;;270    
;;;271      /* Write to I2Cx CCR */
;;;272      I2Cx->CCR = tmpreg;
0000ee  83a6              STRH     r6,[r4,#0x1c]
;;;273      /* Enable the selected I2C peripheral */
;;;274      I2Cx->CR1 |= CR1_PE_Set;
0000f0  8820              LDRH     r0,[r4,#0]
0000f2  f0400001          ORR      r0,r0,#1
0000f6  8020              STRH     r0,[r4,#0]
;;;275    
;;;276    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;277      /* Get the I2Cx CR1 value */
;;;278      tmpreg = I2Cx->CR1;
0000f8  8826              LDRH     r6,[r4,#0]
;;;279      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;280      tmpreg &= CR1_CLEAR_Mask;
0000fa  f64f30f5          MOV      r0,#0xfbf5
0000fe  4006              ANDS     r6,r6,r0
;;;281      /* Configure I2Cx: mode and acknowledgement */
;;;282      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;283      /* Set ACK bit according to I2C_Ack value */
;;;284      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000100  88a8              LDRH     r0,[r5,#4]
000102  8969              LDRH     r1,[r5,#0xa]
000104  4308              ORRS     r0,r0,r1
000106  4306              ORRS     r6,r6,r0
;;;285      /* Write to I2Cx CR1 */
;;;286      I2Cx->CR1 = tmpreg;
000108  8026              STRH     r6,[r4,#0]
;;;287    
;;;288    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;289      /* Set I2Cx Own Address1 and acknowledged address */
;;;290      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
00010a  89a8              LDRH     r0,[r5,#0xc]
00010c  8929              LDRH     r1,[r5,#8]
00010e  4308              ORRS     r0,r0,r1
000110  8120              STRH     r0,[r4,#8]
;;;291    }
000112  b005              ADD      sp,sp,#0x14
000114  e8bd83f0          POP      {r4-r9,pc}
;;;292    
                          ENDP

                  I2C_StructInit PROC
;;;297      */
;;;298    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000118  f2413188          MOV      r1,#0x1388
;;;299    {
;;;300    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;301      /* initialize the I2C_ClockSpeed member */
;;;302      I2C_InitStruct->I2C_ClockSpeed = 5000;
00011c  6001              STR      r1,[r0,#0]
;;;303      /* Initialize the I2C_Mode member */
;;;304      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
00011e  2100              MOVS     r1,#0
000120  8081              STRH     r1,[r0,#4]
;;;305      /* Initialize the I2C_DutyCycle member */
;;;306      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000122  f64b71ff          MOV      r1,#0xbfff
000126  80c1              STRH     r1,[r0,#6]
;;;307      /* Initialize the I2C_OwnAddress1 member */
;;;308      I2C_InitStruct->I2C_OwnAddress1 = 0;
000128  2100              MOVS     r1,#0
00012a  8101              STRH     r1,[r0,#8]
;;;309      /* Initialize the I2C_Ack member */
;;;310      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00012c  8141              STRH     r1,[r0,#0xa]
;;;311      /* Initialize the I2C_AcknowledgedAddress member */
;;;312      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00012e  f44f4180          MOV      r1,#0x4000
000132  8181              STRH     r1,[r0,#0xc]
;;;313    }
000134  4770              BX       lr
;;;314    
                          ENDP

                  I2C_Cmd PROC
;;;321      */
;;;322    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000136  b121              CBZ      r1,|L1.322|
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;326      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;327      if (NewState != DISABLE)
;;;328      {
;;;329        /* Enable the selected I2C peripheral */
;;;330        I2Cx->CR1 |= CR1_PE_Set;
000138  8802              LDRH     r2,[r0,#0]
00013a  f0420201          ORR      r2,r2,#1
00013e  8002              STRH     r2,[r0,#0]
000140  e004              B        |L1.332|
                  |L1.322|
;;;331      }
;;;332      else
;;;333      {
;;;334        /* Disable the selected I2C peripheral */
;;;335        I2Cx->CR1 &= CR1_PE_Reset;
000142  8802              LDRH     r2,[r0,#0]
000144  f64f73fe          MOV      r3,#0xfffe
000148  401a              ANDS     r2,r2,r3
00014a  8002              STRH     r2,[r0,#0]
                  |L1.332|
;;;336      }
;;;337    }
00014c  4770              BX       lr
;;;338    
                          ENDP

                  I2C_DMACmd PROC
;;;345      */
;;;346    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00014e  b121              CBZ      r1,|L1.346|
;;;347    {
;;;348      /* Check the parameters */
;;;349      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;350      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;351      if (NewState != DISABLE)
;;;352      {
;;;353        /* Enable the selected I2C DMA requests */
;;;354        I2Cx->CR2 |= CR2_DMAEN_Set;
000150  8882              LDRH     r2,[r0,#4]
000152  f4426200          ORR      r2,r2,#0x800
000156  8082              STRH     r2,[r0,#4]
000158  e004              B        |L1.356|
                  |L1.346|
;;;355      }
;;;356      else
;;;357      {
;;;358        /* Disable the selected I2C DMA requests */
;;;359        I2Cx->CR2 &= CR2_DMAEN_Reset;
00015a  8882              LDRH     r2,[r0,#4]
00015c  f24f73ff          MOV      r3,#0xf7ff
000160  401a              ANDS     r2,r2,r3
000162  8082              STRH     r2,[r0,#4]
                  |L1.356|
;;;360      }
;;;361    }
000164  4770              BX       lr
;;;362    
                          ENDP

                  I2C_DMALastTransferCmd PROC
;;;369      */
;;;370    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000166  b121              CBZ      r1,|L1.370|
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;374      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;375      if (NewState != DISABLE)
;;;376      {
;;;377        /* Next DMA transfer is the last transfer */
;;;378        I2Cx->CR2 |= CR2_LAST_Set;
000168  8882              LDRH     r2,[r0,#4]
00016a  f4425280          ORR      r2,r2,#0x1000
00016e  8082              STRH     r2,[r0,#4]
000170  e004              B        |L1.380|
                  |L1.370|
;;;379      }
;;;380      else
;;;381      {
;;;382        /* Next DMA transfer is not the last transfer */
;;;383        I2Cx->CR2 &= CR2_LAST_Reset;
000172  8882              LDRH     r2,[r0,#4]
000174  f64e73ff          MOV      r3,#0xefff
000178  401a              ANDS     r2,r2,r3
00017a  8082              STRH     r2,[r0,#4]
                  |L1.380|
;;;384      }
;;;385    }
00017c  4770              BX       lr
;;;386    
                          ENDP

                  I2C_GenerateSTART PROC
;;;393      */
;;;394    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
00017e  b121              CBZ      r1,|L1.394|
;;;395    {
;;;396      /* Check the parameters */
;;;397      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;398      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;399      if (NewState != DISABLE)
;;;400      {
;;;401        /* Generate a START condition */
;;;402        I2Cx->CR1 |= CR1_START_Set;
000180  8802              LDRH     r2,[r0,#0]
000182  f4427280          ORR      r2,r2,#0x100
000186  8002              STRH     r2,[r0,#0]
000188  e004              B        |L1.404|
                  |L1.394|
;;;403      }
;;;404      else
;;;405      {
;;;406        /* Disable the START condition generation */
;;;407        I2Cx->CR1 &= CR1_START_Reset;
00018a  8802              LDRH     r2,[r0,#0]
00018c  f64f63ff          MOV      r3,#0xfeff
000190  401a              ANDS     r2,r2,r3
000192  8002              STRH     r2,[r0,#0]
                  |L1.404|
;;;408      }
;;;409    }
000194  4770              BX       lr
;;;410    
                          ENDP

                  I2C_GenerateSTOP PROC
;;;417      */
;;;418    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000196  b121              CBZ      r1,|L1.418|
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;422      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;423      if (NewState != DISABLE)
;;;424      {
;;;425        /* Generate a STOP condition */
;;;426        I2Cx->CR1 |= CR1_STOP_Set;
000198  8802              LDRH     r2,[r0,#0]
00019a  f4427200          ORR      r2,r2,#0x200
00019e  8002              STRH     r2,[r0,#0]
0001a0  e004              B        |L1.428|
                  |L1.418|
;;;427      }
;;;428      else
;;;429      {
;;;430        /* Disable the STOP condition generation */
;;;431        I2Cx->CR1 &= CR1_STOP_Reset;
0001a2  8802              LDRH     r2,[r0,#0]
0001a4  f64f53ff          MOV      r3,#0xfdff
0001a8  401a              ANDS     r2,r2,r3
0001aa  8002              STRH     r2,[r0,#0]
                  |L1.428|
;;;432      }
;;;433    }
0001ac  4770              BX       lr
;;;434    
                          ENDP

                  I2C_AcknowledgeConfig PROC
;;;441      */
;;;442    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001ae  b121              CBZ      r1,|L1.442|
;;;443    {
;;;444      /* Check the parameters */
;;;445      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;446      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;447      if (NewState != DISABLE)
;;;448      {
;;;449        /* Enable the acknowledgement */
;;;450        I2Cx->CR1 |= CR1_ACK_Set;
0001b0  8802              LDRH     r2,[r0,#0]
0001b2  f4426280          ORR      r2,r2,#0x400
0001b6  8002              STRH     r2,[r0,#0]
0001b8  e004              B        |L1.452|
                  |L1.442|
;;;451      }
;;;452      else
;;;453      {
;;;454        /* Disable the acknowledgement */
;;;455        I2Cx->CR1 &= CR1_ACK_Reset;
0001ba  8802              LDRH     r2,[r0,#0]
0001bc  f64f33ff          MOV      r3,#0xfbff
0001c0  401a              ANDS     r2,r2,r3
0001c2  8002              STRH     r2,[r0,#0]
                  |L1.452|
;;;456      }
;;;457    }
0001c4  4770              BX       lr
;;;458    
                          ENDP

                  I2C_OwnAddress2Config PROC
;;;464      */
;;;465    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
0001c6  2200              MOVS     r2,#0
;;;466    {
;;;467      uint16_t tmpreg = 0;
;;;468    
;;;469      /* Check the parameters */
;;;470      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;471    
;;;472      /* Get the old register value */
;;;473      tmpreg = I2Cx->OAR2;
0001c8  8982              LDRH     r2,[r0,#0xc]
;;;474    
;;;475      /* Reset I2Cx Own address2 bit [7:1] */
;;;476      tmpreg &= OAR2_ADD2_Reset;
0001ca  f64f7301          MOV      r3,#0xff01
0001ce  401a              ANDS     r2,r2,r3
;;;477    
;;;478      /* Set I2Cx Own address2 */
;;;479      tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
0001d0  f00103fe          AND      r3,r1,#0xfe
0001d4  431a              ORRS     r2,r2,r3
;;;480    
;;;481      /* Store the new register value */
;;;482      I2Cx->OAR2 = tmpreg;
0001d6  8182              STRH     r2,[r0,#0xc]
;;;483    }
0001d8  4770              BX       lr
;;;484    
                          ENDP

                  I2C_DualAddressCmd PROC
;;;491      */
;;;492    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001da  b121              CBZ      r1,|L1.486|
;;;493    {
;;;494      /* Check the parameters */
;;;495      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;496      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;497      if (NewState != DISABLE)
;;;498      {
;;;499        /* Enable dual addressing mode */
;;;500        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
0001dc  8982              LDRH     r2,[r0,#0xc]
0001de  f0420201          ORR      r2,r2,#1
0001e2  8182              STRH     r2,[r0,#0xc]
0001e4  e004              B        |L1.496|
                  |L1.486|
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Disable dual addressing mode */
;;;505        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
0001e6  8982              LDRH     r2,[r0,#0xc]
0001e8  f64f73fe          MOV      r3,#0xfffe
0001ec  401a              ANDS     r2,r2,r3
0001ee  8182              STRH     r2,[r0,#0xc]
                  |L1.496|
;;;506      }
;;;507    }
0001f0  4770              BX       lr
;;;508    
                          ENDP

                  I2C_GeneralCallCmd PROC
;;;515      */
;;;516    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001f2  b121              CBZ      r1,|L1.510|
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;520      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;521      if (NewState != DISABLE)
;;;522      {
;;;523        /* Enable generall call */
;;;524        I2Cx->CR1 |= CR1_ENGC_Set;
0001f4  8802              LDRH     r2,[r0,#0]
0001f6  f0420240          ORR      r2,r2,#0x40
0001fa  8002              STRH     r2,[r0,#0]
0001fc  e004              B        |L1.520|
                  |L1.510|
;;;525      }
;;;526      else
;;;527      {
;;;528        /* Disable generall call */
;;;529        I2Cx->CR1 &= CR1_ENGC_Reset;
0001fe  8802              LDRH     r2,[r0,#0]
000200  f64f73bf          MOV      r3,#0xffbf
000204  401a              ANDS     r2,r2,r3
000206  8002              STRH     r2,[r0,#0]
                  |L1.520|
;;;530      }
;;;531    }
000208  4770              BX       lr
;;;532    
                          ENDP

                  I2C_ITConfig PROC
;;;544      */
;;;545    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
00020a  b510              PUSH     {r4,lr}
;;;546    {
;;;547      /* Check the parameters */
;;;548      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;549      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;550      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;551      
;;;552      if (NewState != DISABLE)
00020c  b11a              CBZ      r2,|L1.534|
;;;553      {
;;;554        /* Enable the selected I2C interrupts */
;;;555        I2Cx->CR2 |= I2C_IT;
00020e  8883              LDRH     r3,[r0,#4]
000210  430b              ORRS     r3,r3,r1
000212  8083              STRH     r3,[r0,#4]
000214  e004              B        |L1.544|
                  |L1.534|
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Disable the selected I2C interrupts */
;;;560        I2Cx->CR2 &= (uint16_t)~I2C_IT;
000216  8883              LDRH     r3,[r0,#4]
000218  43cc              MVNS     r4,r1
00021a  b2a4              UXTH     r4,r4
00021c  4023              ANDS     r3,r3,r4
00021e  8083              STRH     r3,[r0,#4]
                  |L1.544|
;;;561      }
;;;562    }
000220  bd10              POP      {r4,pc}
;;;563    
                          ENDP

                  I2C_SendData PROC
;;;569      */
;;;570    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000222  8201              STRH     r1,[r0,#0x10]
;;;571    {
;;;572      /* Check the parameters */
;;;573      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;574      /* Write in the DR register the data to be sent */
;;;575      I2Cx->DR = Data;
;;;576    }
000224  4770              BX       lr
;;;577    
                          ENDP

                  I2C_ReceiveData PROC
;;;582      */
;;;583    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000226  4601              MOV      r1,r0
;;;584    {
;;;585      /* Check the parameters */
;;;586      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;587      /* Return the data in the DR register */
;;;588      return (uint8_t)I2Cx->DR;
000228  8a08              LDRH     r0,[r1,#0x10]
00022a  b2c0              UXTB     r0,r0
;;;589    }
00022c  4770              BX       lr
;;;590    
                          ENDP

                  I2C_Send7bitAddress PROC
;;;600      */
;;;601    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
00022e  b112              CBZ      r2,|L1.566|
;;;602    {
;;;603      /* Check the parameters */
;;;604      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;605      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;606      /* Test on the direction to set/reset the read/write bit */
;;;607      if (I2C_Direction != I2C_Direction_Transmitter)
;;;608      {
;;;609        /* Set the address bit0 for read */
;;;610        Address |= OAR1_ADD0_Set;
000230  f0410101          ORR      r1,r1,#1
000234  e002              B        |L1.572|
                  |L1.566|
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Reset the address bit0 for write */
;;;615        Address &= OAR1_ADD0_Reset;
000236  f64f73fe          MOV      r3,#0xfffe
00023a  4019              ANDS     r1,r1,r3
                  |L1.572|
;;;616      }
;;;617      /* Send the address */
;;;618      I2Cx->DR = Address;
00023c  8201              STRH     r1,[r0,#0x10]
;;;619    }
00023e  4770              BX       lr
;;;620    
                          ENDP

                  I2C_ReadRegister PROC
;;;635      */
;;;636    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000240  4602              MOV      r2,r0
;;;637    {
;;;638      __IO uint32_t tmp = 0;
000242  2300              MOVS     r3,#0
;;;639    
;;;640      /* Check the parameters */
;;;641      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;642      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;643    
;;;644      tmp = (uint32_t) I2Cx;
000244  4613              MOV      r3,r2
;;;645      tmp += I2C_Register;
000246  461a              MOV      r2,r3
000248  440b              ADD      r3,r3,r1
;;;646    
;;;647      /* Return the selected register value */
;;;648      return (*(__IO uint16_t *) tmp);
00024a  8818              LDRH     r0,[r3,#0]
;;;649    }
00024c  4770              BX       lr
;;;650    
                          ENDP

                  I2C_SoftwareResetCmd PROC
;;;657      */
;;;658    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00024e  b121              CBZ      r1,|L1.602|
;;;659    {
;;;660      /* Check the parameters */
;;;661      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;662      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;663      if (NewState != DISABLE)
;;;664      {
;;;665        /* Peripheral under reset */
;;;666        I2Cx->CR1 |= CR1_SWRST_Set;
000250  8802              LDRH     r2,[r0,#0]
000252  f4424200          ORR      r2,r2,#0x8000
000256  8002              STRH     r2,[r0,#0]
000258  e003              B        |L1.610|
                  |L1.602|
;;;667      }
;;;668      else
;;;669      {
;;;670        /* Peripheral not under reset */
;;;671        I2Cx->CR1 &= CR1_SWRST_Reset;
00025a  8802              LDRH     r2,[r0,#0]
00025c  f3c2020e          UBFX     r2,r2,#0,#15
000260  8002              STRH     r2,[r0,#0]
                  |L1.610|
;;;672      }
;;;673    }
000262  4770              BX       lr
;;;674    
                          ENDP

                  I2C_NACKPositionConfig PROC
;;;695      */
;;;696    void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
000264  f5b16f00          CMP      r1,#0x800
;;;697    {
;;;698      /* Check the parameters */
;;;699      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;700      assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
;;;701      
;;;702      /* Check the input parameter */
;;;703      if (I2C_NACKPosition == I2C_NACKPosition_Next)
000268  d104              BNE      |L1.628|
;;;704      {
;;;705        /* Next byte in shift register is the last received byte */
;;;706        I2Cx->CR1 |= I2C_NACKPosition_Next;
00026a  8802              LDRH     r2,[r0,#0]
00026c  f4426200          ORR      r2,r2,#0x800
000270  8002              STRH     r2,[r0,#0]
000272  e004              B        |L1.638|
                  |L1.628|
;;;707      }
;;;708      else
;;;709      {
;;;710        /* Current byte in shift register is the last received byte */
;;;711        I2Cx->CR1 &= I2C_NACKPosition_Current;
000274  8802              LDRH     r2,[r0,#0]
000276  f24f73ff          MOV      r3,#0xf7ff
00027a  401a              ANDS     r2,r2,r3
00027c  8002              STRH     r2,[r0,#0]
                  |L1.638|
;;;712      }
;;;713    }
00027e  4770              BX       lr
;;;714    
                          ENDP

                  I2C_SMBusAlertConfig PROC
;;;723      */
;;;724    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
000280  f5b15f00          CMP      r1,#0x2000
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;728      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;729      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000284  d104              BNE      |L1.656|
;;;730      {
;;;731        /* Drive the SMBusAlert pin Low */
;;;732        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000286  8802              LDRH     r2,[r0,#0]
000288  f4425200          ORR      r2,r2,#0x2000
00028c  8002              STRH     r2,[r0,#0]
00028e  e004              B        |L1.666|
                  |L1.656|
;;;733      }
;;;734      else
;;;735      {
;;;736        /* Drive the SMBusAlert pin High  */
;;;737        I2Cx->CR1 &= I2C_SMBusAlert_High;
000290  8802              LDRH     r2,[r0,#0]
000292  f64d73ff          MOV      r3,#0xdfff
000296  401a              ANDS     r2,r2,r3
000298  8002              STRH     r2,[r0,#0]
                  |L1.666|
;;;738      }
;;;739    }
00029a  4770              BX       lr
;;;740    
                          ENDP

                  I2C_TransmitPEC PROC
;;;747      */
;;;748    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
00029c  b121              CBZ      r1,|L1.680|
;;;749    {
;;;750      /* Check the parameters */
;;;751      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;752      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;753      if (NewState != DISABLE)
;;;754      {
;;;755        /* Enable the selected I2C PEC transmission */
;;;756        I2Cx->CR1 |= CR1_PEC_Set;
00029e  8802              LDRH     r2,[r0,#0]
0002a0  f4425280          ORR      r2,r2,#0x1000
0002a4  8002              STRH     r2,[r0,#0]
0002a6  e004              B        |L1.690|
                  |L1.680|
;;;757      }
;;;758      else
;;;759      {
;;;760        /* Disable the selected I2C PEC transmission */
;;;761        I2Cx->CR1 &= CR1_PEC_Reset;
0002a8  8802              LDRH     r2,[r0,#0]
0002aa  f64e73ff          MOV      r3,#0xefff
0002ae  401a              ANDS     r2,r2,r3
0002b0  8002              STRH     r2,[r0,#0]
                  |L1.690|
;;;762      }
;;;763    }
0002b2  4770              BX       lr
;;;764    
                          ENDP

                  I2C_PECPositionConfig PROC
;;;778      */
;;;779    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
0002b4  f5b16f00          CMP      r1,#0x800
;;;780    {
;;;781      /* Check the parameters */
;;;782      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;783      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;784      if (I2C_PECPosition == I2C_PECPosition_Next)
0002b8  d104              BNE      |L1.708|
;;;785      {
;;;786        /* Next byte in shift register is PEC */
;;;787        I2Cx->CR1 |= I2C_PECPosition_Next;
0002ba  8802              LDRH     r2,[r0,#0]
0002bc  f4426200          ORR      r2,r2,#0x800
0002c0  8002              STRH     r2,[r0,#0]
0002c2  e004              B        |L1.718|
                  |L1.708|
;;;788      }
;;;789      else
;;;790      {
;;;791        /* Current byte in shift register is PEC */
;;;792        I2Cx->CR1 &= I2C_PECPosition_Current;
0002c4  8802              LDRH     r2,[r0,#0]
0002c6  f24f73ff          MOV      r3,#0xf7ff
0002ca  401a              ANDS     r2,r2,r3
0002cc  8002              STRH     r2,[r0,#0]
                  |L1.718|
;;;793      }
;;;794    }
0002ce  4770              BX       lr
;;;795    
                          ENDP

                  I2C_CalculatePEC PROC
;;;802      */
;;;803    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002d0  b121              CBZ      r1,|L1.732|
;;;804    {
;;;805      /* Check the parameters */
;;;806      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;807      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;808      if (NewState != DISABLE)
;;;809      {
;;;810        /* Enable the selected I2C PEC calculation */
;;;811        I2Cx->CR1 |= CR1_ENPEC_Set;
0002d2  8802              LDRH     r2,[r0,#0]
0002d4  f0420220          ORR      r2,r2,#0x20
0002d8  8002              STRH     r2,[r0,#0]
0002da  e004              B        |L1.742|
                  |L1.732|
;;;812      }
;;;813      else
;;;814      {
;;;815        /* Disable the selected I2C PEC calculation */
;;;816        I2Cx->CR1 &= CR1_ENPEC_Reset;
0002dc  8802              LDRH     r2,[r0,#0]
0002de  f64f73df          MOV      r3,#0xffdf
0002e2  401a              ANDS     r2,r2,r3
0002e4  8002              STRH     r2,[r0,#0]
                  |L1.742|
;;;817      }
;;;818    }
0002e6  4770              BX       lr
;;;819    
                          ENDP

                  I2C_GetPEC PROC
;;;824      */
;;;825    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
0002e8  4601              MOV      r1,r0
;;;826    {
;;;827      /* Check the parameters */
;;;828      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;829      /* Return the selected I2C PEC value */
;;;830      return ((I2Cx->SR2) >> 8);
0002ea  8b08              LDRH     r0,[r1,#0x18]
0002ec  1200              ASRS     r0,r0,#8
;;;831    }
0002ee  4770              BX       lr
;;;832    
                          ENDP

                  I2C_ARPCmd PROC
;;;839      */
;;;840    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002f0  b121              CBZ      r1,|L1.764|
;;;841    {
;;;842      /* Check the parameters */
;;;843      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;844      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;845      if (NewState != DISABLE)
;;;846      {
;;;847        /* Enable the selected I2C ARP */
;;;848        I2Cx->CR1 |= CR1_ENARP_Set;
0002f2  8802              LDRH     r2,[r0,#0]
0002f4  f0420210          ORR      r2,r2,#0x10
0002f8  8002              STRH     r2,[r0,#0]
0002fa  e004              B        |L1.774|
                  |L1.764|
;;;849      }
;;;850      else
;;;851      {
;;;852        /* Disable the selected I2C ARP */
;;;853        I2Cx->CR1 &= CR1_ENARP_Reset;
0002fc  8802              LDRH     r2,[r0,#0]
0002fe  f64f73ef          MOV      r3,#0xffef
000302  401a              ANDS     r2,r2,r3
000304  8002              STRH     r2,[r0,#0]
                  |L1.774|
;;;854      }
;;;855    }
000306  4770              BX       lr
;;;856    
                          ENDP

                  I2C_StretchClockCmd PROC
;;;863      */
;;;864    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000308  b921              CBNZ     r1,|L1.788|
;;;865    {
;;;866      /* Check the parameters */
;;;867      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;868      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;869      if (NewState == DISABLE)
;;;870      {
;;;871        /* Enable the selected I2C Clock stretching */
;;;872        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
00030a  8802              LDRH     r2,[r0,#0]
00030c  f0420280          ORR      r2,r2,#0x80
000310  8002              STRH     r2,[r0,#0]
000312  e004              B        |L1.798|
                  |L1.788|
;;;873      }
;;;874      else
;;;875      {
;;;876        /* Disable the selected I2C Clock stretching */
;;;877        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
000314  8802              LDRH     r2,[r0,#0]
000316  f64f737f          MOV      r3,#0xff7f
00031a  401a              ANDS     r2,r2,r3
00031c  8002              STRH     r2,[r0,#0]
                  |L1.798|
;;;878      }
;;;879    }
00031e  4770              BX       lr
;;;880    
                          ENDP

                  I2C_FastModeDutyCycleConfig PROC
;;;889      */
;;;890    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
000320  f5b14f80          CMP      r1,#0x4000
;;;891    {
;;;892      /* Check the parameters */
;;;893      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;894      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;895      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000324  d005              BEQ      |L1.818|
;;;896      {
;;;897        /* I2C fast mode Tlow/Thigh=2 */
;;;898        I2Cx->CCR &= I2C_DutyCycle_2;
000326  8b82              LDRH     r2,[r0,#0x1c]
000328  f64b73ff          MOV      r3,#0xbfff
00032c  401a              ANDS     r2,r2,r3
00032e  8382              STRH     r2,[r0,#0x1c]
000330  e003              B        |L1.826|
                  |L1.818|
;;;899      }
;;;900      else
;;;901      {
;;;902        /* I2C fast mode Tlow/Thigh=16/9 */
;;;903        I2Cx->CCR |= I2C_DutyCycle_16_9;
000332  8b82              LDRH     r2,[r0,#0x1c]
000334  f4424280          ORR      r2,r2,#0x4000
000338  8382              STRH     r2,[r0,#0x1c]
                  |L1.826|
;;;904      }
;;;905    }
00033a  4770              BX       lr
;;;906    
                          ENDP

                  I2C_CheckEvent PROC
;;;1029     */
;;;1030   ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
00033c  b570              PUSH     {r4-r6,lr}
;;;1031   {
00033e  4605              MOV      r5,r0
;;;1032     uint32_t lastevent = 0;
000340  2400              MOVS     r4,#0
;;;1033     uint32_t flag1 = 0, flag2 = 0;
000342  2200              MOVS     r2,#0
000344  2300              MOVS     r3,#0
;;;1034     ErrorStatus status = ERROR;
000346  2000              MOVS     r0,#0
;;;1035   
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1038     assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;1039   
;;;1040     /* Read the I2Cx status register */
;;;1041     flag1 = I2Cx->SR1;
000348  8aaa              LDRH     r2,[r5,#0x14]
;;;1042     flag2 = I2Cx->SR2;
00034a  8b2b              LDRH     r3,[r5,#0x18]
;;;1043     flag2 = flag2 << 16;
00034c  041b              LSLS     r3,r3,#16
;;;1044   
;;;1045     /* Get the last event value from I2C status register */
;;;1046     lastevent = (flag1 | flag2) & FLAG_Mask;
00034e  ea420603          ORR      r6,r2,r3
000352  f026447f          BIC      r4,r6,#0xff000000
;;;1047   
;;;1048     /* Check whether the last event contains the I2C_EVENT */
;;;1049     if ((lastevent & I2C_EVENT) == I2C_EVENT)
000356  ea040601          AND      r6,r4,r1
00035a  428e              CMP      r6,r1
00035c  d101              BNE      |L1.866|
;;;1050     {
;;;1051       /* SUCCESS: last event is equal to I2C_EVENT */
;;;1052       status = SUCCESS;
00035e  2001              MOVS     r0,#1
000360  e000              B        |L1.868|
                  |L1.866|
;;;1053     }
;;;1054     else
;;;1055     {
;;;1056       /* ERROR: last event is different from I2C_EVENT */
;;;1057       status = ERROR;
000362  2000              MOVS     r0,#0
                  |L1.868|
;;;1058     }
;;;1059     /* Return status */
;;;1060     return status;
;;;1061   }
000364  bd70              POP      {r4-r6,pc}
;;;1062   
                          ENDP

                  I2C_GetLastEvent PROC
;;;1077     */
;;;1078   uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
000366  b510              PUSH     {r4,lr}
;;;1079   {
000368  4603              MOV      r3,r0
;;;1080     uint32_t lastevent = 0;
00036a  2000              MOVS     r0,#0
;;;1081     uint32_t flag1 = 0, flag2 = 0;
00036c  2100              MOVS     r1,#0
00036e  2200              MOVS     r2,#0
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1085   
;;;1086     /* Read the I2Cx status register */
;;;1087     flag1 = I2Cx->SR1;
000370  8a99              LDRH     r1,[r3,#0x14]
;;;1088     flag2 = I2Cx->SR2;
000372  8b1a              LDRH     r2,[r3,#0x18]
;;;1089     flag2 = flag2 << 16;
000374  0412              LSLS     r2,r2,#16
;;;1090   
;;;1091     /* Get the last event value from I2C status register */
;;;1092     lastevent = (flag1 | flag2) & FLAG_Mask;
000376  ea410402          ORR      r4,r1,r2
00037a  f024407f          BIC      r0,r4,#0xff000000
;;;1093   
;;;1094     /* Return status */
;;;1095     return lastevent;
;;;1096   }
00037e  bd10              POP      {r4,pc}
;;;1097   
                          ENDP

                  I2C_GetFlagStatus PROC
;;;1132     */
;;;1133   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000380  b530              PUSH     {r4,r5,lr}
;;;1134   {
000382  4602              MOV      r2,r0
;;;1135     FlagStatus bitstatus = RESET;
000384  2000              MOVS     r0,#0
;;;1136     __IO uint32_t i2creg = 0, i2cxbase = 0;
000386  2400              MOVS     r4,#0
000388  2300              MOVS     r3,#0
;;;1137   
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1140     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1141   
;;;1142     /* Get the I2Cx peripheral base address */
;;;1143     i2cxbase = (uint32_t)I2Cx;
00038a  4613              MOV      r3,r2
;;;1144     
;;;1145     /* Read flag register index */
;;;1146     i2creg = I2C_FLAG >> 28;
00038c  0f0c              LSRS     r4,r1,#28
;;;1147     
;;;1148     /* Get bit[23:0] of the flag */
;;;1149     I2C_FLAG &= FLAG_Mask;
00038e  f021417f          BIC      r1,r1,#0xff000000
;;;1150     
;;;1151     if(i2creg != 0)
000392  b10c              CBZ      r4,|L1.920|
;;;1152     {
;;;1153       /* Get the I2Cx SR1 register address */
;;;1154       i2cxbase += 0x14;
000394  3314              ADDS     r3,r3,#0x14
000396  e001              B        |L1.924|
                  |L1.920|
;;;1155     }
;;;1156     else
;;;1157     {
;;;1158       /* Flag in I2Cx SR2 Register */
;;;1159       I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
000398  0c09              LSRS     r1,r1,#16
;;;1160       /* Get the I2Cx SR2 register address */
;;;1161       i2cxbase += 0x18;
00039a  3318              ADDS     r3,r3,#0x18
                  |L1.924|
;;;1162     }
;;;1163     
;;;1164     if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
00039c  681d              LDR      r5,[r3,#0]
00039e  420d              TST      r5,r1
0003a0  d001              BEQ      |L1.934|
;;;1165     {
;;;1166       /* I2C_FLAG is set */
;;;1167       bitstatus = SET;
0003a2  2001              MOVS     r0,#1
0003a4  e000              B        |L1.936|
                  |L1.934|
;;;1168     }
;;;1169     else
;;;1170     {
;;;1171       /* I2C_FLAG is reset */
;;;1172       bitstatus = RESET;
0003a6  2000              MOVS     r0,#0
                  |L1.936|
;;;1173     }
;;;1174     
;;;1175     /* Return the I2C_FLAG status */
;;;1176     return  bitstatus;
;;;1177   }
0003a8  bd30              POP      {r4,r5,pc}
;;;1178   
                          ENDP

                  I2C_ClearFlag PROC
;;;1211     */
;;;1212   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
0003aa  2200              MOVS     r2,#0
;;;1213   {
;;;1214     uint32_t flagpos = 0;
;;;1215     /* Check the parameters */
;;;1216     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1217     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1218     /* Get the I2C flag position */
;;;1219     flagpos = I2C_FLAG & FLAG_Mask;
0003ac  f021427f          BIC      r2,r1,#0xff000000
;;;1220     /* Clear the selected I2C flag */
;;;1221     I2Cx->SR1 = (uint16_t)~flagpos;
0003b0  43d3              MVNS     r3,r2
0003b2  8283              STRH     r3,[r0,#0x14]
;;;1222   }
0003b4  4770              BX       lr
;;;1223   
                          ENDP

                  I2C_GetITStatus PROC
;;;1245     */
;;;1246   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
0003b6  b530              PUSH     {r4,r5,lr}
;;;1247   {
0003b8  4602              MOV      r2,r0
;;;1248     ITStatus bitstatus = RESET;
0003ba  2000              MOVS     r0,#0
;;;1249     uint32_t enablestatus = 0;
0003bc  2300              MOVS     r3,#0
;;;1250   
;;;1251     /* Check the parameters */
;;;1252     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1253     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1254   
;;;1255     /* Check if the interrupt source is enabled or not */
;;;1256     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;
0003be  8894              LDRH     r4,[r2,#4]
0003c0  f00165e0          AND      r5,r1,#0x7000000
0003c4  ea044315          AND      r3,r4,r5,LSR #16
;;;1257     
;;;1258     /* Get bit[23:0] of the flag */
;;;1259     I2C_IT &= FLAG_Mask;
0003c8  f021417f          BIC      r1,r1,#0xff000000
;;;1260   
;;;1261     /* Check the status of the specified I2C flag */
;;;1262     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
0003cc  8a94              LDRH     r4,[r2,#0x14]
0003ce  420c              TST      r4,r1
0003d0  d002              BEQ      |L1.984|
0003d2  b10b              CBZ      r3,|L1.984|
;;;1263     {
;;;1264       /* I2C_IT is set */
;;;1265       bitstatus = SET;
0003d4  2001              MOVS     r0,#1
0003d6  e000              B        |L1.986|
                  |L1.984|
;;;1266     }
;;;1267     else
;;;1268     {
;;;1269       /* I2C_IT is reset */
;;;1270       bitstatus = RESET;
0003d8  2000              MOVS     r0,#0
                  |L1.986|
;;;1271     }
;;;1272     /* Return the I2C_IT status */
;;;1273     return  bitstatus;
;;;1274   }
0003da  bd30              POP      {r4,r5,pc}
;;;1275   
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;1306     */
;;;1307   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
0003dc  2200              MOVS     r2,#0
;;;1308   {
;;;1309     uint32_t flagpos = 0;
;;;1310     /* Check the parameters */
;;;1311     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1312     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1313     /* Get the I2C flag position */
;;;1314     flagpos = I2C_IT & FLAG_Mask;
0003de  f021427f          BIC      r2,r1,#0xff000000
;;;1315     /* Clear the selected I2C flag */
;;;1316     I2Cx->SR1 = (uint16_t)~flagpos;
0003e2  43d3              MVNS     r3,r2
0003e4  8283              STRH     r3,[r0,#0x14]
;;;1317   }
0003e6  4770              BX       lr
                  |L1.1000|
                          DCD      0x40005400
                  |L1.1004|
                          DCD      0x007a1200
                  |L1.1008|
                          DCD      0x000f4240
                  |L1.1012|
                          DCD      0x000186a0
                          ENDP

