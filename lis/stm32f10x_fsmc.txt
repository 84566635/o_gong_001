; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\stm32f10x_fsmc.o --asm_dir=.\lis\ --list_dir=.\lis\ --depend=.\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=521 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\stm32f10x_fsmc.crf stdperiph_driver\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMDeInit PROC
;;;101      */
;;;102    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  0081              LSLS     r1,r0,#2
;;;103    {
000002  f1a141c0          SUB      r1,r1,#0x60000000
000006  b148              CBZ      r0,|L1.28|
;;;104      /* Check the parameter */
;;;105      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;106      
;;;107      /* FSMC_Bank1_NORSRAM1 */
;;;108      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;109      {
;;;110        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;111      }
;;;112      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;113      else
;;;114      {   
;;;115        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000008  f24300d2          MOV      r0,#0x30d2
00000c  f8c10000          STR.W    r0,[r1,#0]
                  |L1.16|
;;;116      }
;;;117      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
000010  f06f4070          MVN      r0,#0xf0000000
000014  6048              STR      r0,[r1,#4]
;;;118      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000016  f8c10104          STR      r0,[r1,#0x104]
;;;119    }
00001a  4770              BX       lr
                  |L1.28|
00001c  f04f4220          MOV      r2,#0xa0000000        ;110
000020  f24300db          MOV      r0,#0x30db            ;110
000024  6010              STR      r0,[r2,#0]            ;110
000026  e7f3              B        |L1.16|
;;;120    
                          ENDP

                  FSMC_NANDDeInit PROC
;;;128      */
;;;129    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000028  b510              PUSH     {r4,lr}
;;;130    {
;;;131      /* Check the parameter */
;;;132      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;133      
;;;134      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;135      {
;;;136        /* Set the FSMC_Bank2 registers to their reset values */
;;;137        FSMC_Bank2->PCR2 = 0x00000018;
00002a  2418              MOVS     r4,#0x18
;;;138        FSMC_Bank2->SR2 = 0x00000040;
00002c  2340              MOVS     r3,#0x40
00002e  f04f4120          MOV      r1,#0xa0000000        ;137
;;;139        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000032  f04f32fc          MOV      r2,#0xfcfcfcfc
000036  2810              CMP      r0,#0x10              ;134
000038  d005              BEQ      |L1.70|
;;;140        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;141      }
;;;142      /* FSMC_Bank3_NAND */  
;;;143      else
;;;144      {
;;;145        /* Set the FSMC_Bank3 registers to their reset values */
;;;146        FSMC_Bank3->PCR3 = 0x00000018;
00003a  f8414f80          STR      r4,[r1,#0x80]!
;;;147        FSMC_Bank3->SR3 = 0x00000040;
00003e  604b              STR      r3,[r1,#4]
;;;148        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000040  608a              STR      r2,[r1,#8]
;;;149        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
000042  60ca              STR      r2,[r1,#0xc]
;;;150      }  
;;;151    }
000044  bd10              POP      {r4,pc}
                  |L1.70|
000046  660c              STR      r4,[r1,#0x60]         ;137
000048  664b              STR      r3,[r1,#0x64]         ;138
00004a  668a              STR      r2,[r1,#0x68]         ;139
00004c  66ca              STR      r2,[r1,#0x6c]         ;140
00004e  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  FSMC_PCCARDDeInit PROC
;;;157      */
;;;158    void FSMC_PCCARDDeInit(void)
000050  f04f4020          MOV      r0,#0xa0000000
;;;159    {
;;;160      /* Set the FSMC_Bank4 registers to their reset values */
;;;161      FSMC_Bank4->PCR4 = 0x00000018; 
000054  2118              MOVS     r1,#0x18
000056  f8401fa0          STR      r1,[r0,#0xa0]!
;;;162      FSMC_Bank4->SR4 = 0x00000000;	
00005a  2100              MOVS     r1,#0
00005c  6041              STR      r1,[r0,#4]
;;;163      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00005e  f04f31fc          MOV      r1,#0xfcfcfcfc
000062  6081              STR      r1,[r0,#8]
;;;164      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000064  60c1              STR      r1,[r0,#0xc]
;;;165      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000066  6101              STR      r1,[r0,#0x10]
;;;166    }
000068  4770              BX       lr
;;;167    
                          ENDP

                  FSMC_NORSRAMInit PROC
;;;175      */
;;;176    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
00006a  b510              PUSH     {r4,lr}
;;;177    { 
00006c  e9d01201          LDRD     r1,r2,[r0,#4]
;;;178      /* Check the parameters */
;;;179      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;180      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;181      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;182      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;183      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;184      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;185      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;186      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;187      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;188      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;189      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;190      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;191      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;192      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;193      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;194      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;195      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;196      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;197      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;198      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;199      
;;;200      /* Bank1 NOR/SRAM control register configuration */ 
;;;201      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000070  4311              ORRS     r1,r1,r2
000072  e9d02303          LDRD     r2,r3,[r0,#0xc]
000076  431a              ORRS     r2,r2,r3
000078  4311              ORRS     r1,r1,r2
00007a  6942              LDR      r2,[r0,#0x14]
00007c  4311              ORRS     r1,r1,r2
00007e  6982              LDR      r2,[r0,#0x18]
000080  4311              ORRS     r1,r1,r2
000082  69c2              LDR      r2,[r0,#0x1c]
000084  4311              ORRS     r1,r1,r2
000086  6a02              LDR      r2,[r0,#0x20]
000088  4311              ORRS     r1,r1,r2
00008a  6a42              LDR      r2,[r0,#0x24]
00008c  4311              ORRS     r1,r1,r2
00008e  6a82              LDR      r2,[r0,#0x28]
000090  4311              ORRS     r1,r1,r2
000092  6ac2              LDR      r2,[r0,#0x2c]
000094  4311              ORRS     r1,r1,r2
000096  6b02              LDR      r2,[r0,#0x30]
000098  4311              ORRS     r1,r1,r2
00009a  6802              LDR      r2,[r0,#0]
00009c  0092              LSLS     r2,r2,#2
00009e  f1a242c0          SUB      r2,r2,#0x60000000
0000a2  6011              STR      r1,[r2,#0]
;;;202                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;203                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;204                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;205                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;206                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;207                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;208                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;209                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;210                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;211                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;212                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;213                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;214    
;;;215      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
0000a4  6881              LDR      r1,[r0,#8]
0000a6  2908              CMP      r1,#8
0000a8  d107              BNE      |L1.186|
;;;216      {
;;;217        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
0000aa  6801              LDR      r1,[r0,#0]
0000ac  0089              LSLS     r1,r1,#2
0000ae  f1a141c0          SUB      r1,r1,#0x60000000
0000b2  680a              LDR      r2,[r1,#0]
0000b4  f0420240          ORR      r2,r2,#0x40
0000b8  600a              STR      r2,[r1,#0]
                  |L1.186|
;;;218      }
;;;219      
;;;220      /* Bank1 NOR/SRAM timing register configuration */
;;;221      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
0000ba  6b41              LDR      r1,[r0,#0x34]
0000bc  e9d12300          LDRD     r2,r3,[r1,#0]
0000c0  ea421203          ORR      r2,r2,r3,LSL #4
0000c4  688b              LDR      r3,[r1,#8]
0000c6  898c              LDRH     r4,[r1,#0xc]
0000c8  021b              LSLS     r3,r3,#8
0000ca  ea434304          ORR      r3,r3,r4,LSL #16
0000ce  431a              ORRS     r2,r2,r3
0000d0  8a0b              LDRH     r3,[r1,#0x10]
0000d2  ea425203          ORR      r2,r2,r3,LSL #20
0000d6  7d0b              LDRB     r3,[r1,#0x14]
0000d8  6989              LDR      r1,[r1,#0x18]
0000da  ea426203          ORR      r2,r2,r3,LSL #24
0000de  430a              ORRS     r2,r2,r1
0000e0  6801              LDR      r1,[r0,#0]
0000e2  0089              LSLS     r1,r1,#2
0000e4  f1a141c0          SUB      r1,r1,#0x60000000
0000e8  604a              STR      r2,[r1,#4]
;;;222                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;223                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;224                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;225                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;226                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;227                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;228                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;229                
;;;230        
;;;231      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;232      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
0000ea  6ac1              LDR      r1,[r0,#0x2c]
0000ec  f5b14f80          CMP      r1,#0x4000
0000f0  d008              BEQ      |L1.260|
;;;233      {
;;;234        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;235        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;236        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;237        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;238        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;239        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;240        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;241                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;242                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;243                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;244                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;245                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;246                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;247      }
;;;248      else
;;;249      {
;;;250        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
0000f2  6800              LDR      r0,[r0,#0]
0000f4  f06f4170          MVN      r1,#0xf0000000
0000f8  0080              LSLS     r0,r0,#2
0000fa  f1a040c0          SUB      r0,r0,#0x60000000
0000fe  f8c01104          STR      r1,[r0,#0x104]
;;;251      }
;;;252    }
000102  bd10              POP      {r4,pc}
                  |L1.260|
000104  6b81              LDR      r1,[r0,#0x38]         ;240
000106  e9d12300          LDRD     r2,r3,[r1,#0]         ;240
00010a  ea421203          ORR      r2,r2,r3,LSL #4       ;240
00010e  688b              LDR      r3,[r1,#8]            ;240
000110  8a0c              LDRH     r4,[r1,#0x10]         ;240
000112  021b              LSLS     r3,r3,#8              ;240
000114  ea435304          ORR      r3,r3,r4,LSL #20      ;240
000118  431a              ORRS     r2,r2,r3              ;240
00011a  7d0b              LDRB     r3,[r1,#0x14]         ;240
00011c  6989              LDR      r1,[r1,#0x18]         ;240
00011e  ea426203          ORR      r2,r2,r3,LSL #24      ;240
000122  6800              LDR      r0,[r0,#0]            ;240
000124  430a              ORRS     r2,r2,r1              ;240
000126  0080              LSLS     r0,r0,#2              ;240
000128  f1a040c0          SUB      r0,r0,#0x60000000     ;240
00012c  f8c02104          STR      r2,[r0,#0x104]        ;240
000130  bd10              POP      {r4,pc}
;;;253    
                          ENDP

                  FSMC_NANDInit PROC
;;;261      */
;;;262    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000132  b530              PUSH     {r4,r5,lr}
;;;263    {
000134  e9d01201          LDRD     r1,r2,[r0,#4]
;;;264      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;265        
;;;266      /* Check the parameters */
;;;267      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;268      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;269      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;270      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;271      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;272      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;273      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;274      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;275      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;276      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;277      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;278      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;279      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;280      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;281      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;282      
;;;283      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;284      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000138  4311              ORRS     r1,r1,r2
00013a  e9d02303          LDRD     r2,r3,[r0,#0xc]
00013e  431a              ORRS     r2,r2,r3
000140  4311              ORRS     r1,r1,r2
000142  6942              LDR      r2,[r0,#0x14]
000144  ea412142          ORR      r1,r1,r2,LSL #9
000148  6982              LDR      r2,[r0,#0x18]
00014a  ea413142          ORR      r1,r1,r2,LSL #13
;;;285                PCR_MemoryType_NAND |
;;;286                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;287                FSMC_NANDInitStruct->FSMC_ECC |
;;;288                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;289                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;290                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;291                
;;;292      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;293      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00014e  69c2              LDR      r2,[r0,#0x1c]
000150  f0410408          ORR      r4,r1,#8              ;284
000154  e9d21300          LDRD     r1,r3,[r2,#0]
000158  ea412103          ORR      r1,r1,r3,LSL #8
00015c  8913              LDRH     r3,[r2,#8]
00015e  7b12              LDRB     r2,[r2,#0xc]
000160  041b              LSLS     r3,r3,#16
000162  ea436202          ORR      r2,r3,r2,LSL #24
;;;294                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;295                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;296                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;297                
;;;298      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;299      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000166  6a03              LDR      r3,[r0,#0x20]
000168  4311              ORRS     r1,r1,r2              ;293
00016a  e9d32500          LDRD     r2,r5,[r3,#0]
00016e  ea422205          ORR      r2,r2,r5,LSL #8
000172  891d              LDRH     r5,[r3,#8]
000174  7b1b              LDRB     r3,[r3,#0xc]
000176  042d              LSLS     r5,r5,#16
000178  ea456303          ORR      r3,r5,r3,LSL #24
00017c  431a              ORRS     r2,r2,r3
;;;300                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;301                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;302                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;303      
;;;304      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;305      {
;;;306        /* FSMC_Bank2_NAND registers configuration */
;;;307        FSMC_Bank2->PCR2 = tmppcr;
00017e  6803              LDR      r3,[r0,#0]
000180  f04f4020          MOV      r0,#0xa0000000
000184  2b10              CMP      r3,#0x10              ;304
000186  d004              BEQ      |L1.402|
;;;308        FSMC_Bank2->PMEM2 = tmppmem;
;;;309        FSMC_Bank2->PATT2 = tmppatt;
;;;310      }
;;;311      else
;;;312      {
;;;313        /* FSMC_Bank3_NAND registers configuration */
;;;314        FSMC_Bank3->PCR3 = tmppcr;
000188  f8404f80          STR      r4,[r0,#0x80]!
;;;315        FSMC_Bank3->PMEM3 = tmppmem;
00018c  6081              STR      r1,[r0,#8]
;;;316        FSMC_Bank3->PATT3 = tmppatt;
00018e  60c2              STR      r2,[r0,#0xc]
;;;317      }
;;;318    }
000190  bd30              POP      {r4,r5,pc}
                  |L1.402|
000192  6604              STR      r4,[r0,#0x60]         ;307
000194  6681              STR      r1,[r0,#0x68]         ;308
000196  66c2              STR      r2,[r0,#0x6c]         ;309
000198  bd30              POP      {r4,r5,pc}
;;;319    
                          ENDP

                  FSMC_PCCARDInit PROC
;;;327      */
;;;328    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
00019a  b510              PUSH     {r4,lr}
;;;329    {
00019c  e9d01200          LDRD     r1,r2,[r0,#0]
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;332      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;333      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;334     
;;;335      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;336      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;337      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;338      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;339      
;;;340      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;341      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;342      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;343      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;344      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;345      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;346      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;347      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;348      
;;;349      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;350      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
0001a0  ea412242          ORR      r2,r1,r2,LSL #9
0001a4  6881              LDR      r1,[r0,#8]
0001a6  2310              MOVS     r3,#0x10
0001a8  ea433141          ORR      r1,r3,r1,LSL #13
0001ac  430a              ORRS     r2,r2,r1
0001ae  f04f4120          MOV      r1,#0xa0000000
0001b2  f8412fa0          STR      r2,[r1,#0xa0]!
;;;351                         FSMC_MemoryDataWidth_16b |  
;;;352                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;353                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;354                
;;;355      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;356      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
0001b6  68c2              LDR      r2,[r0,#0xc]
0001b8  e9d23400          LDRD     r3,r4,[r2,#0]
0001bc  ea432304          ORR      r3,r3,r4,LSL #8
0001c0  8914              LDRH     r4,[r2,#8]
0001c2  7b12              LDRB     r2,[r2,#0xc]
0001c4  0424              LSLS     r4,r4,#16
0001c6  ea446202          ORR      r2,r4,r2,LSL #24
0001ca  4313              ORRS     r3,r3,r2
0001cc  608b              STR      r3,[r1,#8]
;;;357                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;358                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;359                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;360                
;;;361      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;362      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
0001ce  6902              LDR      r2,[r0,#0x10]
0001d0  e9d23400          LDRD     r3,r4,[r2,#0]
0001d4  ea432304          ORR      r3,r3,r4,LSL #8
0001d8  8914              LDRH     r4,[r2,#8]
0001da  7b12              LDRB     r2,[r2,#0xc]
0001dc  0424              LSLS     r4,r4,#16
0001de  ea446202          ORR      r2,r4,r2,LSL #24
0001e2  4313              ORRS     r3,r3,r2
0001e4  60cb              STR      r3,[r1,#0xc]
;;;363                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;364                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;365                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;366                
;;;367      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;368      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
0001e6  6940              LDR      r0,[r0,#0x14]
0001e8  e9d02300          LDRD     r2,r3,[r0,#0]
0001ec  ea422203          ORR      r2,r2,r3,LSL #8
0001f0  8903              LDRH     r3,[r0,#8]
0001f2  7b00              LDRB     r0,[r0,#0xc]
0001f4  041b              LSLS     r3,r3,#16
0001f6  ea436000          ORR      r0,r3,r0,LSL #24
0001fa  4302              ORRS     r2,r2,r0
0001fc  610a              STR      r2,[r1,#0x10]
;;;369                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;370                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;371                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;372    }
0001fe  bd10              POP      {r4,pc}
;;;373    
                          ENDP

                  FSMC_NORSRAMStructInit PROC
;;;379      */
;;;380    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000200  b510              PUSH     {r4,lr}
;;;381    {  
;;;382      /* Reset NOR/SRAM Init structure parameters values */
;;;383      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000202  2100              MOVS     r1,#0
;;;384      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000204  2202              MOVS     r2,#2
000206  e9c01200          STRD     r1,r2,[r0,#0]
;;;385      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;386      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
00020a  6081              STR      r1,[r0,#8]
;;;387      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00020c  60c1              STR      r1,[r0,#0xc]
;;;388      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00020e  6101              STR      r1,[r0,#0x10]
;;;389      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000210  6141              STR      r1,[r0,#0x14]
;;;390      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000212  6181              STR      r1,[r0,#0x18]
;;;391      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;392      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000214  02d2              LSLS     r2,r2,#11
000216  61c1              STR      r1,[r0,#0x1c]
000218  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;393      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00021c  0052              LSLS     r2,r2,#1
00021e  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;394      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;395      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;396      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000222  6301              STR      r1,[r0,#0x30]
000224  6b43              LDR      r3,[r0,#0x34]
000226  220f              MOVS     r2,#0xf
;;;397      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000228  601a              STR      r2,[r3,#0]
00022a  6b43              LDR      r3,[r0,#0x34]
;;;398      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00022c  605a              STR      r2,[r3,#4]
00022e  6b44              LDR      r4,[r0,#0x34]
000230  23ff              MOVS     r3,#0xff
;;;399      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000232  60a3              STR      r3,[r4,#8]
000234  6b44              LDR      r4,[r0,#0x34]
;;;400      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000236  60e2              STR      r2,[r4,#0xc]
000238  6b44              LDR      r4,[r0,#0x34]
;;;401      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
00023a  6122              STR      r2,[r4,#0x10]
00023c  6b44              LDR      r4,[r0,#0x34]
;;;402      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00023e  6162              STR      r2,[r4,#0x14]
000240  6b44              LDR      r4,[r0,#0x34]
;;;403      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000242  61a1              STR      r1,[r4,#0x18]
000244  6b84              LDR      r4,[r0,#0x38]
;;;404      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000246  6022              STR      r2,[r4,#0]
000248  6b84              LDR      r4,[r0,#0x38]
;;;405      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00024a  6062              STR      r2,[r4,#4]
00024c  6b84              LDR      r4,[r0,#0x38]
;;;406      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00024e  60a3              STR      r3,[r4,#8]
000250  6b83              LDR      r3,[r0,#0x38]
;;;407      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000252  60da              STR      r2,[r3,#0xc]
000254  6b83              LDR      r3,[r0,#0x38]
;;;408      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000256  611a              STR      r2,[r3,#0x10]
000258  6b83              LDR      r3,[r0,#0x38]
;;;409      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
00025a  615a              STR      r2,[r3,#0x14]
00025c  6b80              LDR      r0,[r0,#0x38]
00025e  6181              STR      r1,[r0,#0x18]
;;;410    }
000260  bd10              POP      {r4,pc}
;;;411    
                          ENDP

                  FSMC_NANDStructInit PROC
;;;417      */
;;;418    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000262  2110              MOVS     r1,#0x10
;;;419    { 
;;;420      /* Reset NAND Init structure parameters values */
;;;421      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;422      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000264  6001              STR      r1,[r0,#0]
000266  2100              MOVS     r1,#0
;;;423      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000268  6041              STR      r1,[r0,#4]
;;;424      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
00026a  6081              STR      r1,[r0,#8]
;;;425      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00026c  60c1              STR      r1,[r0,#0xc]
;;;426      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00026e  6101              STR      r1,[r0,#0x10]
;;;427      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
000270  6141              STR      r1,[r0,#0x14]
;;;428      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000272  6181              STR      r1,[r0,#0x18]
000274  69c2              LDR      r2,[r0,#0x1c]
000276  21fc              MOVS     r1,#0xfc
;;;429      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000278  6011              STR      r1,[r2,#0]
00027a  69c2              LDR      r2,[r0,#0x1c]
;;;430      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00027c  6051              STR      r1,[r2,#4]
00027e  69c2              LDR      r2,[r0,#0x1c]
;;;431      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000280  6091              STR      r1,[r2,#8]
000282  69c2              LDR      r2,[r0,#0x1c]
;;;432      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000284  60d1              STR      r1,[r2,#0xc]
000286  6a02              LDR      r2,[r0,#0x20]
;;;433      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000288  6011              STR      r1,[r2,#0]
00028a  6a02              LDR      r2,[r0,#0x20]
;;;434      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00028c  6051              STR      r1,[r2,#4]
00028e  6a02              LDR      r2,[r0,#0x20]
;;;435      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
000290  6091              STR      r1,[r2,#8]
000292  6a00              LDR      r0,[r0,#0x20]
000294  60c1              STR      r1,[r0,#0xc]
;;;436    }
000296  4770              BX       lr
;;;437    
                          ENDP

                  FSMC_PCCARDStructInit PROC
;;;443      */
;;;444    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000298  2100              MOVS     r1,#0
;;;445    {
;;;446      /* Reset PCCARD Init structure parameters values */
;;;447      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;448      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
00029a  6001              STR      r1,[r0,#0]
;;;449      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
00029c  6041              STR      r1,[r0,#4]
;;;450      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00029e  6081              STR      r1,[r0,#8]
0002a0  68c2              LDR      r2,[r0,#0xc]
0002a2  21fc              MOVS     r1,#0xfc
;;;451      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002a4  6011              STR      r1,[r2,#0]
0002a6  68c2              LDR      r2,[r0,#0xc]
;;;452      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002a8  6051              STR      r1,[r2,#4]
0002aa  68c2              LDR      r2,[r0,#0xc]
;;;453      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
0002ac  6091              STR      r1,[r2,#8]
0002ae  68c2              LDR      r2,[r0,#0xc]
;;;454      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002b0  60d1              STR      r1,[r2,#0xc]
0002b2  6902              LDR      r2,[r0,#0x10]
;;;455      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002b4  6011              STR      r1,[r2,#0]
0002b6  6902              LDR      r2,[r0,#0x10]
;;;456      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002b8  6051              STR      r1,[r2,#4]
0002ba  6902              LDR      r2,[r0,#0x10]
;;;457      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
0002bc  6091              STR      r1,[r2,#8]
0002be  6902              LDR      r2,[r0,#0x10]
;;;458      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002c0  60d1              STR      r1,[r2,#0xc]
0002c2  6942              LDR      r2,[r0,#0x14]
;;;459      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002c4  6011              STR      r1,[r2,#0]
0002c6  6942              LDR      r2,[r0,#0x14]
;;;460      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002c8  6051              STR      r1,[r2,#4]
0002ca  6942              LDR      r2,[r0,#0x14]
;;;461      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
0002cc  6091              STR      r1,[r2,#8]
0002ce  6940              LDR      r0,[r0,#0x14]
0002d0  60c1              STR      r1,[r0,#0xc]
;;;462    }
0002d2  4770              BX       lr
;;;463    
                          ENDP

                  FSMC_NORSRAMCmd PROC
;;;474      */
;;;475    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
0002d4  0080              LSLS     r0,r0,#2
;;;476    {
;;;477      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;478      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      
;;;480      if (NewState != DISABLE)
;;;481      {
;;;482        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;483        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
0002d6  f1a040c0          SUB      r0,r0,#0x60000000
0002da  2900              CMP      r1,#0                 ;480
;;;484      }
;;;485      else
;;;486      {
;;;487        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;488        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
0002dc  6801              LDR      r1,[r0,#0]
0002de  d002              BEQ      |L1.742|
0002e0  f0410101          ORR      r1,r1,#1              ;483
0002e4  e001              B        |L1.746|
                  |L1.742|
0002e6  4a64              LDR      r2,|L1.1144|
0002e8  4011              ANDS     r1,r1,r2
                  |L1.746|
0002ea  6001              STR      r1,[r0,#0]            ;483
;;;489      }
;;;490    }
0002ec  4770              BX       lr
;;;491    
                          ENDP

                  FSMC_NANDCmd PROC
;;;500      */
;;;501    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
0002ee  f04f4220          MOV      r2,#0xa0000000
;;;502    {
0002f2  b151              CBZ      r1,|L1.778|
;;;503      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;504      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;505      
;;;506      if (NewState != DISABLE)
;;;507      {
;;;508        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;509        if(FSMC_Bank == FSMC_Bank2_NAND)
0002f4  2810              CMP      r0,#0x10
0002f6  d004              BEQ      |L1.770|
;;;510        {
;;;511          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
;;;512        }
;;;513        else
;;;514        {
;;;515          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
0002f8  f8520f80          LDR      r0,[r2,#0x80]!
0002fc  f0400004          ORR      r0,r0,#4
000300  e00a              B        |L1.792|
                  |L1.770|
000302  6e10              LDR      r0,[r2,#0x60]         ;511
000304  f0400004          ORR      r0,r0,#4              ;511
000308  e00a              B        |L1.800|
                  |L1.778|
;;;516        }
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;521        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;522        {
;;;523          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
00030a  495b              LDR      r1,|L1.1144|
00030c  1ec9              SUBS     r1,r1,#3
00030e  2810              CMP      r0,#0x10              ;521
000310  d004              BEQ      |L1.796|
;;;524        }
;;;525        else
;;;526        {
;;;527          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
000312  f8520f80          LDR      r0,[r2,#0x80]!
000316  4008              ANDS     r0,r0,r1
                  |L1.792|
000318  6010              STR      r0,[r2,#0]            ;515
;;;528        }
;;;529      }
;;;530    }
00031a  4770              BX       lr
                  |L1.796|
00031c  6e10              LDR      r0,[r2,#0x60]         ;523
00031e  4008              ANDS     r0,r0,r1              ;523
                  |L1.800|
000320  6610              STR      r0,[r2,#0x60]         ;511
000322  4770              BX       lr
;;;531    
                          ENDP

                  FSMC_PCCARDCmd PROC
;;;537      */
;;;538    void FSMC_PCCARDCmd(FunctionalState NewState)
000324  f04f4120          MOV      r1,#0xa0000000
;;;539    {
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      
;;;542      if (NewState != DISABLE)
000328  2800              CMP      r0,#0
;;;543      {
;;;544        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;545        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
;;;546      }
;;;547      else
;;;548      {
;;;549        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;550        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
00032a  f8510fa0          LDR      r0,[r1,#0xa0]!
00032e  d002              BEQ      |L1.822|
000330  f0400004          ORR      r0,r0,#4              ;545
000334  e002              B        |L1.828|
                  |L1.822|
000336  4a50              LDR      r2,|L1.1144|
000338  1ed2              SUBS     r2,r2,#3
00033a  4010              ANDS     r0,r0,r2
                  |L1.828|
00033c  6008              STR      r0,[r1,#0]            ;545
;;;551      }
;;;552    }
00033e  4770              BX       lr
;;;553    
                          ENDP

                  FSMC_NANDECCCmd PROC
;;;563      */
;;;564    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000340  f04f4220          MOV      r2,#0xa0000000
;;;565    {
000344  b151              CBZ      r1,|L1.860|
;;;566      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;567      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;568      
;;;569      if (NewState != DISABLE)
;;;570      {
;;;571        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;572        if(FSMC_Bank == FSMC_Bank2_NAND)
000346  2810              CMP      r0,#0x10
000348  d004              BEQ      |L1.852|
;;;573        {
;;;574          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
;;;575        }
;;;576        else
;;;577        {
;;;578          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
00034a  f8520f80          LDR      r0,[r2,#0x80]!
00034e  f0400040          ORR      r0,r0,#0x40
000352  e00a              B        |L1.874|
                  |L1.852|
000354  6e10              LDR      r0,[r2,#0x60]         ;574
000356  f0400040          ORR      r0,r0,#0x40           ;574
00035a  e00a              B        |L1.882|
                  |L1.860|
;;;579        }
;;;580      }
;;;581      else
;;;582      {
;;;583        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;584        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;585        {
;;;586          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
00035c  4946              LDR      r1,|L1.1144|
00035e  393f              SUBS     r1,r1,#0x3f
000360  2810              CMP      r0,#0x10              ;584
000362  d004              BEQ      |L1.878|
;;;587        }
;;;588        else
;;;589        {
;;;590          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
000364  f8520f80          LDR      r0,[r2,#0x80]!
000368  4008              ANDS     r0,r0,r1
                  |L1.874|
00036a  6010              STR      r0,[r2,#0]            ;578
;;;591        }
;;;592      }
;;;593    }
00036c  4770              BX       lr
                  |L1.878|
00036e  6e10              LDR      r0,[r2,#0x60]         ;586
000370  4008              ANDS     r0,r0,r1              ;586
                  |L1.882|
000372  6610              STR      r0,[r2,#0x60]         ;574
000374  4770              BX       lr
;;;594    
                          ENDP

                  FSMC_GetECC PROC
;;;602      */
;;;603    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000376  f04f4120          MOV      r1,#0xa0000000
;;;604    {
;;;605      uint32_t eccval = 0x00000000;
;;;606      
;;;607      if(FSMC_Bank == FSMC_Bank2_NAND)
00037a  2810              CMP      r0,#0x10
00037c  d002              BEQ      |L1.900|
;;;608      {
;;;609        /* Get the ECCR2 register value */
;;;610        eccval = FSMC_Bank2->ECCR2;
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Get the ECCR3 register value */
;;;615        eccval = FSMC_Bank3->ECCR3;
00037e  f8d10094          LDR      r0,[r1,#0x94]
;;;616      }
;;;617      /* Return the error correction code value */
;;;618      return(eccval);
;;;619    }
000382  4770              BX       lr
                  |L1.900|
000384  6f48              LDR      r0,[r1,#0x74]         ;610
000386  4770              BX       lr
;;;620    
                          ENDP

                  FSMC_ITConfig PROC
;;;636      */
;;;637    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000388  b510              PUSH     {r4,lr}
;;;638    {
;;;639      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;640      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;641      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;642      
;;;643      if (NewState != DISABLE)
;;;644      {
;;;645        /* Enable the selected FSMC_Bank2 interrupts */
;;;646        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;647        {
;;;648          FSMC_Bank2->SR2 |= FSMC_IT;
;;;649        }
;;;650        /* Enable the selected FSMC_Bank3 interrupts */
;;;651        else if (FSMC_Bank == FSMC_Bank3_NAND)
00038a  f44f7480          MOV      r4,#0x100
00038e  f04f4320          MOV      r3,#0xa0000000        ;648
000392  b172              CBZ      r2,|L1.946|
000394  2810              CMP      r0,#0x10              ;646
000396  d004              BEQ      |L1.930|
000398  42a0              CMP      r0,r4
00039a  d105              BNE      |L1.936|
;;;652        {
;;;653          FSMC_Bank3->SR3 |= FSMC_IT;
00039c  f8530f84          LDR      r0,[r3,#0x84]!
0003a0  e004              B        |L1.940|
                  |L1.930|
0003a2  6e58              LDR      r0,[r3,#0x64]         ;648
0003a4  4308              ORRS     r0,r0,r1              ;648
0003a6  e00d              B        |L1.964|
                  |L1.936|
;;;654        }
;;;655        /* Enable the selected FSMC_Bank4 interrupts */
;;;656        else
;;;657        {
;;;658          FSMC_Bank4->SR4 |= FSMC_IT;    
0003a8  f8530fa4          LDR      r0,[r3,#0xa4]!
                  |L1.940|
0003ac  4308              ORRS     r0,r0,r1
                  |L1.942|
0003ae  6018              STR      r0,[r3,#0]
;;;659        }
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected FSMC_Bank2 interrupts */
;;;664        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;665        {
;;;666          
;;;667          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;668        }
;;;669        /* Disable the selected FSMC_Bank3 interrupts */
;;;670        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;671        {
;;;672          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;673        }
;;;674        /* Disable the selected FSMC_Bank4 interrupts */
;;;675        else
;;;676        {
;;;677          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;678        }
;;;679      }
;;;680    }
0003b0  bd10              POP      {r4,pc}
                  |L1.946|
0003b2  2810              CMP      r0,#0x10              ;664
0003b4  d004              BEQ      |L1.960|
0003b6  42a0              CMP      r0,r4                 ;670
0003b8  d106              BNE      |L1.968|
0003ba  f8530f84          LDR      r0,[r3,#0x84]!        ;672
0003be  e005              B        |L1.972|
                  |L1.960|
0003c0  6e58              LDR      r0,[r3,#0x64]         ;667
0003c2  4388              BICS     r0,r0,r1              ;667
                  |L1.964|
0003c4  6658              STR      r0,[r3,#0x64]         ;648
0003c6  bd10              POP      {r4,pc}
                  |L1.968|
0003c8  f8530fa4          LDR      r0,[r3,#0xa4]!        ;677
                  |L1.972|
0003cc  4388              BICS     r0,r0,r1              ;672
0003ce  e7ee              B        |L1.942|
;;;681    
                          ENDP

                  FSMC_GetFlagStatus PROC
;;;696      */
;;;697    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
0003d0  4603              MOV      r3,r0
;;;698    {
;;;699      FlagStatus bitstatus = RESET;
0003d2  2000              MOVS     r0,#0
;;;700      uint32_t tmpsr = 0x00000000;
;;;701      
;;;702      /* Check the parameters */
;;;703      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;704      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;705      
;;;706      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;707      {
;;;708        tmpsr = FSMC_Bank2->SR2;
0003d4  f04f4220          MOV      r2,#0xa0000000
0003d8  2b10              CMP      r3,#0x10              ;706
0003da  d008              BEQ      |L1.1006|
;;;709      }  
;;;710      else if(FSMC_Bank == FSMC_Bank3_NAND)
0003dc  f5b37f80          CMP      r3,#0x100
0003e0  d007              BEQ      |L1.1010|
;;;711      {
;;;712        tmpsr = FSMC_Bank3->SR3;
;;;713      }
;;;714      /* FSMC_Bank4_PCCARD*/
;;;715      else
;;;716      {
;;;717        tmpsr = FSMC_Bank4->SR4;
0003e2  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L1.998|
;;;718      } 
;;;719      
;;;720      /* Get the flag status */
;;;721      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
0003e6  420a              TST      r2,r1
0003e8  d000              BEQ      |L1.1004|
;;;722      {
;;;723        bitstatus = SET;
0003ea  2001              MOVS     r0,#1
                  |L1.1004|
;;;724      }
;;;725      else
;;;726      {
;;;727        bitstatus = RESET;
;;;728      }
;;;729      /* Return the flag status */
;;;730      return bitstatus;
;;;731    }
0003ec  4770              BX       lr
                  |L1.1006|
0003ee  6e52              LDR      r2,[r2,#0x64]         ;708
0003f0  e7f9              B        |L1.998|
                  |L1.1010|
0003f2  f8d22084          LDR      r2,[r2,#0x84]         ;712
0003f6  e7f6              B        |L1.998|
;;;732    
                          ENDP

                  FSMC_ClearFlag PROC
;;;746      */
;;;747    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
0003f8  f04f4220          MOV      r2,#0xa0000000
;;;748    {
;;;749     /* Check the parameters */
;;;750      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;751      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;752        
;;;753      if(FSMC_Bank == FSMC_Bank2_NAND)
0003fc  2810              CMP      r0,#0x10
0003fe  d007              BEQ      |L1.1040|
;;;754      {
;;;755        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;756      }  
;;;757      else if(FSMC_Bank == FSMC_Bank3_NAND)
000400  f5b07f80          CMP      r0,#0x100
000404  d008              BEQ      |L1.1048|
;;;758      {
;;;759        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;760      }
;;;761      /* FSMC_Bank4_PCCARD*/
;;;762      else
;;;763      {
;;;764        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
000406  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.1034|
00040a  4388              BICS     r0,r0,r1
00040c  6010              STR      r0,[r2,#0]
;;;765      }
;;;766    }
00040e  4770              BX       lr
                  |L1.1040|
000410  6e50              LDR      r0,[r2,#0x64]         ;755
000412  4388              BICS     r0,r0,r1              ;755
000414  6650              STR      r0,[r2,#0x64]         ;755
000416  4770              BX       lr
                  |L1.1048|
000418  f8520f84          LDR      r0,[r2,#0x84]!        ;759
00041c  e7f5              B        |L1.1034|
;;;767    
                          ENDP

                  FSMC_GetITStatus PROC
;;;781      */
;;;782    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00041e  4603              MOV      r3,r0
;;;783    {
;;;784      ITStatus bitstatus = RESET;
000420  2000              MOVS     r0,#0
;;;785      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;786      
;;;787      /* Check the parameters */
;;;788      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;789      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;790      
;;;791      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;792      {
;;;793        tmpsr = FSMC_Bank2->SR2;
000422  f04f4220          MOV      r2,#0xa0000000
000426  2b10              CMP      r3,#0x10              ;791
000428  d00c              BEQ      |L1.1092|
;;;794      }  
;;;795      else if(FSMC_Bank == FSMC_Bank3_NAND)
00042a  f5b37f80          CMP      r3,#0x100
00042e  d00b              BEQ      |L1.1096|
;;;796      {
;;;797        tmpsr = FSMC_Bank3->SR3;
;;;798      }
;;;799      /* FSMC_Bank4_PCCARD*/
;;;800      else
;;;801      {
;;;802        tmpsr = FSMC_Bank4->SR4;
000430  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L1.1076|
;;;803      } 
;;;804      
;;;805      itstatus = tmpsr & FSMC_IT;
000434  420a              TST      r2,r1
;;;806      
;;;807      itenable = tmpsr & (FSMC_IT >> 3);
000436  ea0201d1          AND      r1,r2,r1,LSR #3
;;;808      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
00043a  d002              BEQ      |L1.1090|
00043c  2900              CMP      r1,#0
00043e  d000              BEQ      |L1.1090|
;;;809      {
;;;810        bitstatus = SET;
000440  2001              MOVS     r0,#1
                  |L1.1090|
;;;811      }
;;;812      else
;;;813      {
;;;814        bitstatus = RESET;
;;;815      }
;;;816      return bitstatus; 
;;;817    }
000442  4770              BX       lr
                  |L1.1092|
000444  6e52              LDR      r2,[r2,#0x64]         ;793
000446  e7f5              B        |L1.1076|
                  |L1.1096|
000448  f8d22084          LDR      r2,[r2,#0x84]         ;797
00044c  e7f2              B        |L1.1076|
;;;818    
                          ENDP

                  FSMC_ClearITPendingBit PROC
;;;832      */
;;;833    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00044e  f04f4220          MOV      r2,#0xa0000000
;;;834    {
;;;835      /* Check the parameters */
;;;836      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;837      assert_param(IS_FSMC_IT(FSMC_IT));
;;;838        
;;;839      if(FSMC_Bank == FSMC_Bank2_NAND)
000452  2810              CMP      r0,#0x10
000454  d008              BEQ      |L1.1128|
;;;840      {
;;;841        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;842      }  
;;;843      else if(FSMC_Bank == FSMC_Bank3_NAND)
000456  f5b07f80          CMP      r0,#0x100
00045a  d00a              BEQ      |L1.1138|
;;;844      {
;;;845        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;846      }
;;;847      /* FSMC_Bank4_PCCARD*/
;;;848      else
;;;849      {
;;;850        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00045c  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.1120|
000460  ea2000d1          BIC      r0,r0,r1,LSR #3
000464  6010              STR      r0,[r2,#0]
;;;851      }
;;;852    }
000466  4770              BX       lr
                  |L1.1128|
000468  6e50              LDR      r0,[r2,#0x64]         ;841
00046a  ea2000d1          BIC      r0,r0,r1,LSR #3       ;841
00046e  6650              STR      r0,[r2,#0x64]         ;841
000470  4770              BX       lr
                  |L1.1138|
000472  f8520f84          LDR      r0,[r2,#0x84]!        ;845
000476  e7f3              B        |L1.1120|
;;;853    
                          ENDP

                  |L1.1144|
                          DCD      0x000ffffe
