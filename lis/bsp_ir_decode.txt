; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\bsp_ir_decode.o --asm_dir=.\lis\ --list_dir=.\lis\ --depend=.\bsp_ir_decode.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=521 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\bsp_ir_decode.crf user\src\bsp_ir_decode.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  bsp_InitIRD PROC
;;;39     */
;;;40     void bsp_InitIRD(void)
000000  b508              PUSH     {r3,lr}
;;;41     {
;;;42     	GPIO_InitTypeDef GPIO_InitStructure;
;;;43     
;;;44     	/* 打开GPIO时钟 */
;;;45     	RCC_APB2PeriphClockCmd(RCC_IRD, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;46     
;;;47     	/* 配置DQ为输入引脚 */
;;;48     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;		/* 设为输出口 */
00000a  2004              MOVS     r0,#4
00000c  f88d0003          STRB     r0,[sp,#3]
;;;49     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	/* IO口最大速度 */
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;50     	GPIO_InitStructure.GPIO_Pin = PIN_IRD;
000016  f44f7080          MOV      r0,#0x100
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;51     	GPIO_Init(PORT_IRD, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4862              LDR      r0,|L1.428|
000022  f7fffffe          BL       GPIO_Init
;;;52     }
000026  bd08              POP      {r3,pc}
;;;53     
                          ENDP

                  IRD_StartWork PROC
;;;61     */
;;;62     void IRD_StartWork(void)
000028  b570              PUSH     {r4-r6,lr}
;;;63     {
;;;64     	TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;65     	NVIC_InitTypeDef NVIC_InitStructure;
;;;66     	TIM_TimeBaseInitTypeDef TIM_TimeBase;
;;;67     //  TIM_OCInitTypeDef  TIM_OCInitStructure;	
;;;68     	TIM_DeInit(TIM1);
00002a  4e61              LDR      r6,|L1.432|
00002c  b088              SUB      sp,sp,#0x20           ;63
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       TIM_DeInit
;;;69     	
;;;70     	TIM_TimeBase.TIM_Period=65535;
000034  f64f70ff          MOV      r0,#0xffff
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;71     	TIM_TimeBase.TIM_Prescaler=639;
00003c  f240207f          MOV      r0,#0x27f
000040  f8ad000c          STRH     r0,[sp,#0xc]
;;;72     	TIM_TimeBase.TIM_ClockDivision = TIM_CKD_DIV1;  
000044  2400              MOVS     r4,#0
000046  f8ad4012          STRH     r4,[sp,#0x12]
;;;73     	TIM_TimeBase.TIM_CounterMode = TIM_CounterMode_Up;
00004a  f8ad400e          STRH     r4,[sp,#0xe]
;;;74     	TIM_TimeBaseInit(TIM1,&TIM_TimeBase);
00004e  a903              ADD      r1,sp,#0xc
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       TIM_TimeBaseInit
;;;75     	
;;;76     	/* TIM1 clock enable */
;;;77     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
000056  2101              MOVS     r1,#1
000058  02c8              LSLS     r0,r1,#11
00005a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;78     
;;;79     // 	  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;                           //???PWM??1  
;;;80     //     TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;                
;;;81     //     TIM_OCInitStructure.TIM_Pulse = 50;                                       //?????,???????????,??????  
;;;82     //     TIM_OCInitStructure.TIM_OCPolarity =TIM_OCPolarity_High;                    //?????????CCR1?????  
;;;83     //     TIM_OC1Init(TIM1, &TIM_OCInitStructure);                                    //????1      
;;;84     //     TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
;;;85     
;;;86     
;;;87     	/* TIM1 chennel1 configuration : PA.8 */
;;;88       bsp_InitIRD();
00005e  f7fffffe          BL       bsp_InitIRD
;;;89     
;;;90     	/* Enable the TIM1 global Interrupt */
;;;91     	NVIC_InitStructure.NVIC_IRQChannel = TIM1_CC_IRQn;
000062  201b              MOVS     r0,#0x1b
000064  f88d0018          STRB     r0,[sp,#0x18]
;;;92     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000068  f88d4019          STRB     r4,[sp,#0x19]
;;;93     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00006c  2501              MOVS     r5,#1
00006e  f88d501a          STRB     r5,[sp,#0x1a]
;;;94     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000072  f88d501b          STRB     r5,[sp,#0x1b]
;;;95     	NVIC_Init(&NVIC_InitStructure);
000076  a806              ADD      r0,sp,#0x18
000078  f7fffffe          BL       NVIC_Init
;;;96     
;;;97     	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
00007c  f8ad4000          STRH     r4,[sp,#0]
;;;98     	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_BothEdge;
000080  200a              MOVS     r0,#0xa
000082  f8ad0002          STRH     r0,[sp,#2]
;;;99     	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
;;;100    	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
;;;101    	TIM_ICInitStructure.TIM_ICFilter = 0x7;
000086  2007              MOVS     r0,#7
000088  f8ad5004          STRH     r5,[sp,#4]            ;99
00008c  f8ad0008          STRH     r0,[sp,#8]
000090  f8ad4006          STRH     r4,[sp,#6]            ;100
;;;102    	
;;;103    	TIM_ICInit(TIM1, &TIM_ICInitStructure);
000094  4669              MOV      r1,sp
000096  4630              MOV      r0,r6
000098  f7fffffe          BL       TIM_ICInit
;;;104    	
;;;105    	/* 设置分频为 1680/2， 捕获计数器值的单位正好是 10us, 方便脉宽比较 */
;;;106      //TIM_PrescalerConfig(TIM1, 639, TIM_PSCReloadMode_Immediate);
;;;107    	
;;;108    	/* TIM enable counter */
;;;109    	TIM_Cmd(TIM1, ENABLE);
00009c  2101              MOVS     r1,#1
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       TIM_Cmd
;;;110    
;;;111    	/* Enable the CC3 Interrupt Request */
;;;112    	TIM_ITConfig(TIM1, TIM_IT_CC1, ENABLE);
0000a4  2201              MOVS     r2,#1
0000a6  2102              MOVS     r1,#2
0000a8  4630              MOV      r0,r6
0000aa  f7fffffe          BL       TIM_ITConfig
;;;113    	//TIM_CtrlPWMOutputs(TIM1,ENABLE);
;;;114    	g_tIR.LastCapture = 0;	
0000ae  4841              LDR      r0,|L1.436|
0000b0  8004              STRH     r4,[r0,#0]
;;;115    	g_tIR.Status = 0;
0000b2  7084              STRB     r4,[r0,#2]
;;;116    }
0000b4  b008              ADD      sp,sp,#0x20
0000b6  bd70              POP      {r4-r6,pc}
;;;117    
                          ENDP

                  IRD_StopWork PROC
;;;125    */
;;;126    void IRD_StopWork(void)
0000b8  b510              PUSH     {r4,lr}
;;;127    {
;;;128    	TIM_Cmd(TIM1, DISABLE);
0000ba  4c3d              LDR      r4,|L1.432|
0000bc  2100              MOVS     r1,#0
0000be  4620              MOV      r0,r4
0000c0  f7fffffe          BL       TIM_Cmd
;;;129    	
;;;130    	TIM_ITConfig(TIM1, TIM_IT_CC1, DISABLE);	
0000c4  4620              MOV      r0,r4
0000c6  2200              MOVS     r2,#0
0000c8  e8bd4010          POP      {r4,lr}
0000cc  2102              MOVS     r1,#2
0000ce  f7ffbffe          B.W      TIM_ITConfig
;;;131    }
;;;132    
                          ENDP

                  IRD_DecodeNec PROC
;;;141    //uint16_t width_lenth[50]= {0};
;;;142    void IRD_DecodeNec(uint16_t _width)
0000d2  e92d41f0          PUSH     {r4-r8,lr}
;;;143    {
;;;144    	static uint16_t s_LowWidth;
;;;145    	static uint8_t s_Byte;
;;;146    	static uint8_t s_Bit;
;;;147    	
;;;148    //	static uint8_t width_conut = 0;
;;;149    	uint16_t TotalWitdh;
;;;150    	
;;;151    	/* NEC 格式 （5段）
;;;152    		1、引导码  9ms低 + 4.5ms高
;;;153    		2、低8位地址码  0=1.125ms  1=2.25ms    bit0先传
;;;154    		3、高8位地址码  0=1.125ms  1=2.25ms
;;;155    		4、8位数据      0=1.125ms  1=2.25ms
;;;156    		5、8为数码反码  0=1.125ms  1=2.25ms
;;;157    	*/
;;;158    // //width_lenth[width_conut] = _width;
;;;159    // 	width_conut++;
;;;160    loop1:	
;;;161    	switch (g_tIR.Status)
;;;162    	{
;;;163    		case 0:			/* 929 等待引导码低信号  7ms - 11ms */
;;;164    			if ((_width > 1300) && (_width < 1400))
;;;165    			{
;;;166    				g_tIR.Status = 1;
;;;167    				s_Byte = 0;
0000d6  4937              LDR      r1,|L1.436|
0000d8  2301              MOVS     r3,#1                 ;161
0000da  1e89              SUBS     r1,r1,#2
0000dc  2500              MOVS     r5,#0
;;;168    				s_Bit = 0;
;;;169    			}
;;;170    			break;
;;;171    
;;;172    // 		case 1:			/* 413 判断引导码高信号  3ms - 6ms */
;;;173    // 			if ((_width > 313) && (_width < 600))	/* 引导码 4.5ms */
;;;174    // 			{
;;;175    // 				g_tIR.Status = 2;
;;;176    // 			}
;;;177    // 			else if ((_width > 150) && (_width < 250))	/* 2.25ms */
;;;178    // 			{
;;;179    // 				#ifdef IR_REPEAT_SEND_EN				
;;;180    // 					if (g_tIR.RepeatCount >= IR_REPEAT_FILTER)
;;;181    // 					{
;;;182    // 						bsp_PutKey(g_tIR.RxBuf[2] + IR_KEY_STRAT);	/* 连发码 */
;;;183    // 					}
;;;184    // 					else
;;;185    // 					{
;;;186    // 						g_tIR.RepeatCount++;
;;;187    // 					}
;;;188    // 				#endif
;;;189    // 				g_tIR.Status = 0;	/* 复位解码状态 */
;;;190    // 			}
;;;191    // 			else
;;;192    // 			{
;;;193    // 				/* 异常脉宽 */
;;;194    // 				g_tIR.Status = 0;	/* 复位解码状态 */
;;;195    // 			}
;;;196    // 			break;
;;;197    		
;;;198    // 		case 2:			/* 低电平期间 0.56ms */
;;;199    // 			if ((_width > 10) && (_width < 100))
;;;200    // 			{		
;;;201    // 				g_tIR.Status = 3;
;;;202    // 				s_LowWidth = _width;	/* 保存低电平宽度 */
;;;203    // 			}
;;;204    // 			else	/* 异常脉宽 */
;;;205    // 			{
;;;206    // 				/* 异常脉宽 */
;;;207    // 				g_tIR.Status = 0;	/* 复位解码器状态 */	
;;;208    // 				goto loop1;		/* 继续判断同步信号 */
;;;209    // 			}
;;;210    // 			break;
;;;211    
;;;212    		case 1:			/* 85+25, 64+157 开始连续解码32bit */						
;;;213    			TotalWitdh =  _width;
;;;214    			/* 0的宽度为1.125ms，1的宽度为2.25ms */				
;;;215    			s_Byte >>= 1;
;;;216    			if ((TotalWitdh > 92) && (TotalWitdh < 132))
0000de  f1a0065d          SUB      r6,r0,#0x5d
;;;217    			{
;;;218    				;					/* bit = 0 */
;;;219    			}
;;;220    			else if ((TotalWitdh > 205) && (TotalWitdh < 245))
0000e2  f1a002ce          SUB      r2,r0,#0xce
0000e6  1c8c              ADDS     r4,r1,#2              ;161
                  |L1.232|
0000e8  78a7              LDRB     r7,[r4,#2]            ;161  ; g_tIR
0000ea  b1f7              CBZ      r7,|L1.298|
0000ec  2f01              CMP      r7,#1                 ;161
0000ee  d123              BNE      |L1.312|
0000f0  780f              LDRB     r7,[r1,#0]            ;215  ; s_Byte
0000f2  087f              LSRS     r7,r7,#1              ;215
0000f4  700f              STRB     r7,[r1,#0]            ;215
0000f6  2e27              CMP      r6,#0x27              ;216
0000f8  d304              BCC      |L1.260|
0000fa  2a27              CMP      r2,#0x27
0000fc  d21e              BCS      |L1.316|
;;;221    			{
;;;222    				s_Byte += 0x80;		/* bit = 1 */
0000fe  b2f8              UXTB     r0,r7
000100  3080              ADDS     r0,r0,#0x80
000102  7008              STRB     r0,[r1,#0]
                  |L1.260|
;;;223    			}	
;;;224    			else
;;;225    			{
;;;226    				/* 异常脉宽 */
;;;227    				g_tIR.Status = 0;	/* 复位解码器状态 */	
;;;228    				goto loop1;		/* 继续判断同步信号 */
;;;229    			}
;;;230    			
;;;231    			s_Bit++;
000104  7848              LDRB     r0,[r1,#1]  ; s_Bit
000106  1c40              ADDS     r0,r0,#1
000108  b2c0              UXTB     r0,r0
00010a  7048              STRB     r0,[r1,#1]
;;;232    			if (s_Bit == 8)	/* 收齐8位 */
00010c  2808              CMP      r0,#8
00010e  d017              BEQ      |L1.320|
;;;233    			{
;;;234    				g_tIR.RxBuf[0] = s_Byte;
;;;235    				s_Byte = 0;
;;;236    			}
;;;237    			else if (s_Bit == 16)	/* 收齐16位 */
000110  2810              CMP      r0,#0x10
000112  d018              BEQ      |L1.326|
;;;238    			{
;;;239    				g_tIR.RxBuf[1] = s_Byte;
;;;240    				s_Byte = 0;
;;;241    			}
;;;242    			else if (s_Bit == 24)	/* 收齐24位 */
000114  2818              CMP      r0,#0x18
000116  d019              BEQ      |L1.332|
;;;243    			{
;;;244    				g_tIR.RxBuf[2] = s_Byte;
;;;245    				s_Byte = 0;
;;;246    			}
;;;247    			else if (s_Bit == 32)	/* 收齐32位 */
000118  2820              CMP      r0,#0x20
00011a  d10d              BNE      |L1.312|
;;;248    			{
;;;249    				g_tIR.RxBuf[3] = s_Byte;
00011c  7808              LDRB     r0,[r1,#0]  ; s_Byte
00011e  71a0              STRB     r0,[r4,#6]
;;;250    								
;;;251    				if (g_tIR.RxBuf[2] + g_tIR.RxBuf[3] == 255)	/* 检查校验 */
000120  7961              LDRB     r1,[r4,#5]  ; g_tIR
000122  4408              ADD      r0,r0,r1
000124  28ff              CMP      r0,#0xff
000126  d015              BEQ      |L1.340|
000128  e019              B        |L1.350|
                  |L1.298|
00012a  f2a05015          SUB      r0,r0,#0x515
00012e  2863              CMP      r0,#0x63              ;164
000130  d202              BCS      |L1.312|
000132  70a3              STRB     r3,[r4,#2]            ;166
000134  700d              STRB     r5,[r1,#0]            ;167
000136  704d              STRB     r5,[r1,#1]            ;168
                  |L1.312|
;;;252    				{
;;;253    					bsp_PutKey(g_tIR.RxBuf[2] + IR_KEY_STRAT);	/* 将键值放入KEY FIFO */
;;;254    					
;;;255    					g_tIR.RepeatCount = 0;	/* 重发计数器 */										
;;;256    				}
;;;257    				
;;;258    				g_tIR.Status = 0;	/* 等待下一组编码 */
;;;259    				break;
;;;260    			}
;;;261    			g_tIR.Status = 1;	/* 继续下一个bit */
;;;262    			break;						
;;;263    	}
;;;264    }
000138  e8bd81f0          POP      {r4-r8,pc}
                  |L1.316|
00013c  70a5              STRB     r5,[r4,#2]            ;227
00013e  e7d3              B        |L1.232|
                  |L1.320|
000140  7808              LDRB     r0,[r1,#0]            ;234  ; s_Byte
000142  70e0              STRB     r0,[r4,#3]            ;234
000144  e004              B        |L1.336|
                  |L1.326|
000146  7808              LDRB     r0,[r1,#0]            ;239  ; s_Byte
000148  7120              STRB     r0,[r4,#4]            ;239
00014a  e001              B        |L1.336|
                  |L1.332|
00014c  7808              LDRB     r0,[r1,#0]            ;244  ; s_Byte
00014e  7160              STRB     r0,[r4,#5]            ;244
                  |L1.336|
000150  700d              STRB     r5,[r1,#0]            ;245
000152  e7f1              B        |L1.312|
                  |L1.340|
000154  3180              ADDS     r1,r1,#0x80
000156  b2c8              UXTB     r0,r1                 ;253
000158  f7fffffe          BL       bsp_PutKey
00015c  71e5              STRB     r5,[r4,#7]            ;255
                  |L1.350|
00015e  70a5              STRB     r5,[r4,#2]            ;258
000160  e7ea              B        |L1.312|
;;;265    
                          ENDP

                  TIM1_CC_IRQHandler PROC
;;;275    //static uint16_t NowCapture_temp_count=0;
;;;276    void TIM1_CC_IRQHandler(void)
000162  b510              PUSH     {r4,lr}
;;;277    {
;;;278    	uint16_t NowCapture;
;;;279    	uint16_t Width;
;;;280    	
;;;281    	if (TIM_GetITStatus(TIM1, TIM_IT_CC1))
000164  4c12              LDR      r4,|L1.432|
000166  2102              MOVS     r1,#2
000168  4620              MOV      r0,r4
00016a  f7fffffe          BL       TIM_GetITStatus
00016e  2800              CMP      r0,#0
000170  d01a              BEQ      |L1.424|
;;;282    	{
;;;283    		TIM_ClearITPendingBit(TIM1, TIM_IT_CC1);
000172  2102              MOVS     r1,#2
000174  4620              MOV      r0,r4
000176  f7fffffe          BL       TIM_ClearITPendingBit
;;;284    
;;;285    		NowCapture = TIM_GetCapture1(TIM1);	/* 读取捕获的计数器值，计数器值从0-65535循环计数 */
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       TIM_GetCapture1
;;;286        //NowCapture_temp[NowCapture_temp_count++] = NowCapture;
;;;287    		if (NowCapture >= g_tIR.LastCapture)
000180  490c              LDR      r1,|L1.436|
000182  880a              LDRH     r2,[r1,#0]  ; g_tIR
000184  4282              CMP      r2,r0
000186  d801              BHI      |L1.396|
;;;288    		{
;;;289    			Width = NowCapture - g_tIR.LastCapture;
000188  1a83              SUBS     r3,r0,r2
00018a  e003              B        |L1.404|
                  |L1.396|
;;;290    		}
;;;291    		else if (NowCapture < g_tIR.LastCapture)	/* 计数器抵达最大并翻转 */
;;;292    		{
;;;293    			Width = ((0xFFFF - g_tIR.LastCapture) + NowCapture);
00018c  f64f73ff          MOV      r3,#0xffff
000190  1a9b              SUBS     r3,r3,r2
000192  4403              ADD      r3,r3,r0
                  |L1.404|
;;;294    		}			
;;;295    		
;;;296    		if ((g_tIR.Status == 0) && (g_tIR.LastCapture == 0))
000194  788c              LDRB     r4,[r1,#2]  ; g_tIR
000196  b29b              UXTH     r3,r3                 ;293
000198  b904              CBNZ     r4,|L1.412|
00019a  b122              CBZ      r2,|L1.422|
                  |L1.412|
;;;297    		{
;;;298    			g_tIR.LastCapture = NowCapture;
;;;299    			return;
;;;300    		}
;;;301    				
;;;302    		g_tIR.LastCapture = NowCapture;	/* 保存当前计数器，用于下次计算差值 */
00019c  8008              STRH     r0,[r1,#0]
;;;303    		
;;;304    		IRD_DecodeNec(Width);		/* 解码 */		
00019e  e8bd4010          POP      {r4,lr}
0001a2  4618              MOV      r0,r3
0001a4  e7fe              B        IRD_DecodeNec
                  |L1.422|
0001a6  8008              STRH     r0,[r1,#0]            ;298
                  |L1.424|
;;;305    	}
;;;306    }
0001a8  bd10              POP      {r4,pc}
;;;307    
                          ENDP

0001aa  0000              DCW      0x0000
                  |L1.428|
                          DCD      0x40010800
                  |L1.432|
                          DCD      0x40012c00
                  |L1.436|
                          DCD      ||.data||+0x2

                          AREA ||.data||, DATA, ALIGN=1

                  s_Byte
000000  00                DCB      0x00
                  s_Bit
000001  00                DCB      0x00
                  g_tIR
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000
000008  0000              DCB      0x00,0x00
