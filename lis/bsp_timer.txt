; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\bsp_timer.o --asm_dir=.\lis\ --list_dir=.\lis\ --depend=.\bsp_timer.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\user\inc -I.\stdperiph_driver\inc -I.\cmsis -ID:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\RV31\INC -Id:\Keil_v5\ARM\CMSIS\Include -Id:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=521 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\bsp_timer.crf user\src\bsp_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  bsp_InitTimer PROC
;;;47     */
;;;48     void bsp_InitTimer(void)
000000  b510              PUSH     {r4,lr}
;;;49     {
;;;50     	uint8_t i;
;;;51     
;;;52     	/* 清零所有的软件定时器 */
;;;53     	for (i = 0; i < TMR_COUNT; i++)
000002  2000              MOVS     r0,#0
;;;54     	{
;;;55     		s_tTmr[i].Count = 0;
000004  4a75              LDR      r2,|L1.476|
000006  4601              MOV      r1,r0                 ;53
                  |L1.8|
000008  eb000440          ADD      r4,r0,r0,LSL #1
00000c  eb020384          ADD      r3,r2,r4,LSL #2
000010  6059              STR      r1,[r3,#4]
;;;56     		s_tTmr[i].PreLoad = 0;
000012  6099              STR      r1,[r3,#8]
;;;57     		s_tTmr[i].Flag = 0;
000014  7059              STRB     r1,[r3,#1]
;;;58     		s_tTmr[i].Mode = TMR_ONCE_MODE;	/* 缺省是1次性工作模式 */
000016  f8021024          STRB     r1,[r2,r4,LSL #2]
00001a  1c40              ADDS     r0,r0,#1
00001c  b2c0              UXTB     r0,r0                 ;53
00001e  2804              CMP      r0,#4                 ;53
000020  d3f2              BCC      |L1.8|
;;;59     	}
;;;60     
;;;61     	/*
;;;62     		配置systic中断周期为1ms，并启动systick中断。
;;;63     
;;;64         	SystemCoreClock 是固件中定义的系统内核时钟，对于STM32F4XX,一般为 168MHz
;;;65     
;;;66         	SysTick_Config() 函数的形参表示内核时钟多少个周期后触发一次Systick定时中断.
;;;67     	    	-- SystemCoreClock / 1000  表示定时频率为 1000Hz， 也就是定时周期为  1ms
;;;68     	    	-- SystemCoreClock / 500   表示定时频率为 500Hz，  也就是定时周期为  2ms
;;;69     	    	-- SystemCoreClock / 2000  表示定时频率为 2000Hz， 也就是定时周期为  500us
;;;70     
;;;71         	对于常规的应用，我们一般取定时周期1ms。对于低速CPU或者低功耗应用，可以设置定时周期为 10ms
;;;72         */
;;;73     	SysTick_Config(SystemCoreClock / 800);//10ms
000022  486f              LDR      r0,|L1.480|
000024  f44f7248          MOV      r2,#0x320
000028  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00002a  fbb0f0f2          UDIV     r0,r0,r2
00002e  f1b07f80          CMP      r0,#0x1000000
000032  d20c              BCS      |L1.78|
000034  f020427f          BIC      r2,r0,#0xff000000
000038  f04f20e0          MOV      r0,#0xe000e000
00003c  1e52              SUBS     r2,r2,#1
00003e  6142              STR      r2,[r0,#0x14]
000040  4b68              LDR      r3,|L1.484|
000042  22f0              MOVS     r2,#0xf0
000044  f8832d14          STRB     r2,[r3,#0xd14]
000048  6181              STR      r1,[r0,#0x18]
00004a  2107              MOVS     r1,#7
00004c  6101              STR      r1,[r0,#0x10]
                  |L1.78|
;;;74     }
00004e  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  SysTick_ISR PROC
;;;86     extern void bsp_RunPer2s(void);
;;;87     void SysTick_ISR(void)
000050  b570              PUSH     {r4-r6,lr}
;;;88     {
;;;89     	static uint8_t ms_count = 0,s_count = 0;
;;;90     	uint8_t i;
;;;91     
;;;92     	/* 每隔1ms进来1次 （仅用于 bsp_DelayMS） */
;;;93     	if (s_uiDelayCount > 0)
000052  4c65              LDR      r4,|L1.488|
000054  6860              LDR      r0,[r4,#4]  ; s_uiDelayCount
;;;94     	{
;;;95     		if (--s_uiDelayCount == 0)
;;;96     		{
;;;97     			s_ucTimeOutFlag = 1;
000056  2201              MOVS     r2,#1
000058  b120              CBZ      r0,|L1.100|
00005a  6860              LDR      r0,[r4,#4]            ;95  ; s_uiDelayCount
00005c  1e40              SUBS     r0,r0,#1              ;95
00005e  6060              STR      r0,[r4,#4]            ;95  ; s_uiDelayCount
000060  d100              BNE      |L1.100|
000062  7022              STRB     r2,[r4,#0]
                  |L1.100|
;;;98     		}
;;;99     	}
;;;100    
;;;101    	/* 每隔1ms，对软件定时器的计数器进行减一操作 */
;;;102    	for (i = 0; i < TMR_COUNT; i++)
;;;103    	{
;;;104    		bsp_SoftTimerDec(&s_tTmr[i]);
000064  4b5d              LDR      r3,|L1.476|
000066  2100              MOVS     r1,#0                 ;102
                  |L1.104|
000068  eb010041          ADD      r0,r1,r1,LSL #1
00006c  eb030080          ADD      r0,r3,r0,LSL #2
000070  6845              LDR      r5,[r0,#4]
000072  b14d              CBZ      r5,|L1.136|
000074  6845              LDR      r5,[r0,#4]
000076  1e6d              SUBS     r5,r5,#1
000078  6045              STR      r5,[r0,#4]
00007a  d105              BNE      |L1.136|
00007c  7042              STRB     r2,[r0,#1]
00007e  7805              LDRB     r5,[r0,#0]
000080  2d01              CMP      r5,#1
000082  d101              BNE      |L1.136|
000084  6885              LDR      r5,[r0,#8]
000086  6045              STR      r5,[r0,#4]
                  |L1.136|
000088  1c49              ADDS     r1,r1,#1
00008a  b2c9              UXTB     r1,r1                 ;102
00008c  2904              CMP      r1,#4                 ;102
00008e  d3eb              BCC      |L1.104|
;;;105    	}
;;;106    
;;;107    	/* 全局运行时间每1ms增1 */
;;;108    	g_iRunTime++;
000090  68a0              LDR      r0,[r4,#8]  ; g_iRunTime
000092  1c40              ADDS     r0,r0,#1
000094  60a0              STR      r0,[r4,#8]  ; g_iRunTime
;;;109    	if (g_iRunTime == 0x7FFFFFFF)	/* 这个变量是 int32_t 类型，最大数为 0x7FFFFFFF */
000096  68a0              LDR      r0,[r4,#8]  ; g_iRunTime
000098  f06f4100          MVN      r1,#0x80000000
00009c  2500              MOVS     r5,#0
00009e  4288              CMP      r0,r1
0000a0  d100              BNE      |L1.164|
;;;110    	{
;;;111    		g_iRunTime = 0;
0000a2  60a5              STR      r5,[r4,#8]  ; g_iRunTime
                  |L1.164|
;;;112    	}
;;;113    
;;;114    	bsp_RunPer1ms();		/* 每隔1ms调用一次此函数，此函数在 bsp.c */
0000a4  f7fffffe          BL       bsp_RunPer1ms
;;;115    
;;;116    	if (++ms_count >= 10)
0000a8  7860              LDRB     r0,[r4,#1]  ; ms_count
0000aa  1c40              ADDS     r0,r0,#1
0000ac  b2c0              UXTB     r0,r0
0000ae  7060              STRB     r0,[r4,#1]
0000b0  280a              CMP      r0,#0xa
0000b2  d30b              BCC      |L1.204|
;;;117    	{
;;;118    		ms_count = 0;
0000b4  7065              STRB     r5,[r4,#1]
;;;119    
;;;120    		bsp_RunPer10ms();	/* 每隔10ms调用一次此函数，此函数在 bsp.c */
0000b6  f7fffffe          BL       bsp_RunPer10ms
;;;121    		
;;;122    		if(++s_count>100)
0000ba  78a0              LDRB     r0,[r4,#2]  ; s_count
0000bc  1c40              ADDS     r0,r0,#1
0000be  b2c0              UXTB     r0,r0
0000c0  70a0              STRB     r0,[r4,#2]
0000c2  2864              CMP      r0,#0x64
0000c4  d902              BLS      |L1.204|
;;;123    		{
;;;124    			bsp_RunPer2s();	/* 每隔10ms调用一次此函数，此函数在 bsp.c */
0000c6  f7fffffe          BL       bsp_RunPer2s
;;;125    			s_count = 0;
0000ca  70a5              STRB     r5,[r4,#2]
                  |L1.204|
;;;126    		}
;;;127    	}
;;;128    }
0000cc  bd70              POP      {r4-r6,pc}
;;;129    
                          ENDP

                  bsp_DelayMS PROC
;;;163    */
;;;164    void bsp_DelayMS(uint32_t n)
0000ce  b510              PUSH     {r4,lr}
;;;165    {
0000d0  2800              CMP      r0,#0
0000d2  d010              BEQ      |L1.246|
;;;166    	if (n == 0)
;;;167    	{
;;;168    		return;
;;;169    	}
;;;170    	else if (n == 1)
0000d4  2801              CMP      r0,#1
0000d6  d100              BNE      |L1.218|
;;;171    	{
;;;172    		n = 2;
0000d8  2002              MOVS     r0,#2
                  |L1.218|
;;;173    	}
;;;174    
;;;175    	DISABLE_INT();  			/* 关中断 */
0000da  2101              MOVS     r1,#1
0000dc  f3818810          MSR      PRIMASK,r1
;;;176    
;;;177    	s_uiDelayCount = n;
0000e0  4c41              LDR      r4,|L1.488|
0000e2  6060              STR      r0,[r4,#4]  ; s_uiDelayCount
;;;178    	s_ucTimeOutFlag = 0;
0000e4  2000              MOVS     r0,#0
0000e6  7020              STRB     r0,[r4,#0]
0000e8  f3808810          MSR      PRIMASK,r0
                  |L1.236|
;;;179    
;;;180    	ENABLE_INT();  				/* 开中断 */
;;;181    
;;;182    	while (1)
;;;183    	{
;;;184    		bsp_Idle();				/* CPU空闲执行的操作， 见 bsp.c 和 bsp.h 文件 */
0000ec  f7fffffe          BL       bsp_Idle
;;;185    
;;;186    		/*
;;;187    			等待延迟时间到
;;;188    			注意：编译器认为 s_ucTimeOutFlag = 0，所以可能优化错误，因此 s_ucTimeOutFlag 变量必须申明为 volatile
;;;189    		*/
;;;190    		if (s_ucTimeOutFlag == 1)
0000f0  7820              LDRB     r0,[r4,#0]  ; s_ucTimeOutFlag
0000f2  2801              CMP      r0,#1
0000f4  d1fa              BNE      |L1.236|
                  |L1.246|
;;;191    		{
;;;192    			break;
;;;193    		}
;;;194    	}
;;;195    }
0000f6  bd10              POP      {r4,pc}
;;;196    
                          ENDP

                  bsp_DelayUS PROC
;;;204    */
;;;205    void bsp_DelayUS(uint32_t n)
0000f8  b570              PUSH     {r4-r6,lr}
;;;206    {
;;;207        uint32_t ticks;
;;;208        uint32_t told;
;;;209        uint32_t tnow;
;;;210        uint32_t tcnt = 0;
;;;211        uint32_t reload;
;;;212           
;;;213    	reload = SysTick->LOAD;                
0000fa  f04f23e0          MOV      r3,#0xe000e000
0000fe  2100              MOVS     r1,#0                 ;210
000100  695d              LDR      r5,[r3,#0x14]
;;;214        ticks = n * (SystemCoreClock / 1000000);	 /* 需要的节拍数 */  
000102  4a37              LDR      r2,|L1.480|
000104  4c39              LDR      r4,|L1.492|
000106  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
000108  fbb2f4f4          UDIV     r4,r2,r4
;;;215        
;;;216        tcnt = 0;
;;;217        told = SysTick->VAL;             /* 刚进入时的计数器值 */
00010c  699a              LDR      r2,[r3,#0x18]
00010e  4344              MULS     r4,r0,r4              ;214
                  |L1.272|
;;;218    
;;;219        while (1)
;;;220        {
;;;221            tnow = SysTick->VAL;    
000110  6998              LDR      r0,[r3,#0x18]
;;;222            if (tnow != told)
000112  4290              CMP      r0,r2
000114  d0fc              BEQ      |L1.272|
;;;223            {    
;;;224                /* SYSTICK是一个递减的计数器 */    
;;;225                if (tnow < told)
000116  d202              BCS      |L1.286|
;;;226                {
;;;227                    tcnt += told - tnow;    
000118  eba20200          SUB      r2,r2,r0
00011c  e002              B        |L1.292|
                  |L1.286|
;;;228                }
;;;229                /* 重新装载递减 */
;;;230                else
;;;231                {
;;;232                    tcnt += reload - tnow + told;    
00011e  eba50600          SUB      r6,r5,r0
000122  4432              ADD      r2,r2,r6
                  |L1.292|
000124  4411              ADD      r1,r1,r2
;;;233                }        
;;;234                told = tnow;
000126  4602              MOV      r2,r0
;;;235    
;;;236                /* 时间超过/等于要延迟的时间,则退出 */
;;;237                if (tcnt >= ticks)
000128  42a1              CMP      r1,r4
00012a  d3f1              BCC      |L1.272|
;;;238                {
;;;239                	break;
;;;240                }
;;;241            }  
;;;242        }
;;;243    } 
00012c  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  bsp_StartTimer PROC
;;;254    */
;;;255    void bsp_StartTimer(uint8_t _id, uint32_t _period)
00012e  2804              CMP      r0,#4
;;;256    {
000130  d300              BCC      |L1.308|
                  |L1.306|
;;;257    	if (_id >= TMR_COUNT)
;;;258    	{
;;;259    		/* 打印出错的源代码文件名、函数名称 */
;;;260    		//BSP_Printf("Error: file %s, function %s()\r\n", __FILE__, __FUNCTION__);
;;;261    		while(1); /* 参数异常，死机等待看门狗复位 */
000132  e7fe              B        |L1.306|
                  |L1.308|
;;;262    	}
;;;263    
;;;264    	DISABLE_INT();  			/* 关中断 */
000134  2201              MOVS     r2,#1
000136  f3828810          MSR      PRIMASK,r2
;;;265    
;;;266    	s_tTmr[_id].Count = _period;		/* 实时计数器初值 */
00013a  4a28              LDR      r2,|L1.476|
00013c  eb000340          ADD      r3,r0,r0,LSL #1
000140  eb020083          ADD      r0,r2,r3,LSL #2
000144  6041              STR      r1,[r0,#4]
;;;267    	s_tTmr[_id].PreLoad = _period;		/* 计数器自动重装值，仅自动模式起作用 */
000146  6081              STR      r1,[r0,#8]
;;;268    	s_tTmr[_id].Flag = 0;				/* 定时时间到标志 */
000148  2100              MOVS     r1,#0
00014a  7041              STRB     r1,[r0,#1]
;;;269    	s_tTmr[_id].Mode = TMR_ONCE_MODE;	/* 1次性工作模式 */
00014c  f8021023          STRB     r1,[r2,r3,LSL #2]
000150  f3818810          MSR      PRIMASK,r1
;;;270    
;;;271    	ENABLE_INT();  				/* 开中断 */
;;;272    }
000154  4770              BX       lr
;;;273    
                          ENDP

                  bsp_StartAutoTimer PROC
;;;282    */
;;;283    void bsp_StartAutoTimer(uint8_t _id, uint32_t _period)
000156  2804              CMP      r0,#4
;;;284    {
000158  d300              BCC      |L1.348|
                  |L1.346|
;;;285    	if (_id >= TMR_COUNT)
;;;286    	{
;;;287    		/* 打印出错的源代码文件名、函数名称 */
;;;288    		//BSP_Printf("Error: file %s, function %s()\r\n", __FILE__, __FUNCTION__);
;;;289    		while(1); /* 参数异常，死机等待看门狗复位 */
00015a  e7fe              B        |L1.346|
                  |L1.348|
;;;290    	}
;;;291    
;;;292    	DISABLE_INT();  		/* 关中断 */
00015c  2201              MOVS     r2,#1
00015e  f3828810          MSR      PRIMASK,r2
;;;293    
;;;294    	s_tTmr[_id].Count = _period;			/* 实时计数器初值 */
000162  4a1e              LDR      r2,|L1.476|
000164  eb000340          ADD      r3,r0,r0,LSL #1
000168  eb020083          ADD      r0,r2,r3,LSL #2
00016c  6041              STR      r1,[r0,#4]
;;;295    	s_tTmr[_id].PreLoad = _period;		/* 计数器自动重装值，仅自动模式起作用 */
00016e  6081              STR      r1,[r0,#8]
;;;296    	s_tTmr[_id].Flag = 0;				/* 定时时间到标志 */
000170  2100              MOVS     r1,#0
000172  7041              STRB     r1,[r0,#1]
;;;297    	s_tTmr[_id].Mode = TMR_AUTO_MODE;	/* 自动工作模式 */
000174  2001              MOVS     r0,#1
000176  f8020023          STRB     r0,[r2,r3,LSL #2]
00017a  f3818810          MSR      PRIMASK,r1
;;;298    
;;;299    	ENABLE_INT();  			/* 开中断 */
;;;300    }
00017e  4770              BX       lr
;;;301    
                          ENDP

                  bsp_StopTimer PROC
;;;309    */
;;;310    void bsp_StopTimer(uint8_t _id)
000180  2804              CMP      r0,#4
;;;311    {
000182  d300              BCC      |L1.390|
                  |L1.388|
;;;312    	if (_id >= TMR_COUNT)
;;;313    	{
;;;314    		/* 打印出错的源代码文件名、函数名称 */
;;;315    		//BSP_Printf("Error: file %s, function %s()\r\n", __FILE__, __FUNCTION__);
;;;316    		while(1); /* 参数异常，死机等待看门狗复位 */
000184  e7fe              B        |L1.388|
                  |L1.390|
;;;317    	}
;;;318    
;;;319    	DISABLE_INT();  	/* 关中断 */
000186  2101              MOVS     r1,#1
000188  f3818810          MSR      PRIMASK,r1
;;;320    
;;;321    	s_tTmr[_id].Count = 0;				/* 实时计数器初值 */
00018c  4a13              LDR      r2,|L1.476|
00018e  eb000040          ADD      r0,r0,r0,LSL #1
000192  eb020380          ADD      r3,r2,r0,LSL #2
000196  2100              MOVS     r1,#0
000198  6059              STR      r1,[r3,#4]
;;;322    	s_tTmr[_id].Flag = 0;				/* 定时时间到标志 */
00019a  7059              STRB     r1,[r3,#1]
;;;323    	s_tTmr[_id].Mode = TMR_ONCE_MODE;	/* 自动工作模式 */
00019c  f8021020          STRB     r1,[r2,r0,LSL #2]
0001a0  f3818810          MSR      PRIMASK,r1
;;;324    
;;;325    	ENABLE_INT();  		/* 开中断 */
;;;326    }
0001a4  4770              BX       lr
;;;327    
                          ENDP

                  bsp_CheckTimer PROC
;;;336    */
;;;337    uint8_t bsp_CheckTimer(uint8_t _id)
0001a6  2804              CMP      r0,#4
;;;338    {
0001a8  d207              BCS      |L1.442|
;;;339    	if (_id >= TMR_COUNT)
;;;340    	{
;;;341    		return 0;
;;;342    	}
;;;343    
;;;344    	if (s_tTmr[_id].Flag == 1)
0001aa  eb000140          ADD      r1,r0,r0,LSL #1
0001ae  480b              LDR      r0,|L1.476|
0001b0  eb000081          ADD      r0,r0,r1,LSL #2
0001b4  7841              LDRB     r1,[r0,#1]
0001b6  2901              CMP      r1,#1
0001b8  d001              BEQ      |L1.446|
                  |L1.442|
;;;345    	{
;;;346    		s_tTmr[_id].Flag = 0;
;;;347    		return 1;
;;;348    	}
;;;349    	else
;;;350    	{
;;;351    		return 0;
0001ba  2000              MOVS     r0,#0
;;;352    	}
;;;353    }
0001bc  4770              BX       lr
                  |L1.446|
0001be  2100              MOVS     r1,#0                 ;346
0001c0  7041              STRB     r1,[r0,#1]            ;346
0001c2  2001              MOVS     r0,#1                 ;347
0001c4  4770              BX       lr
;;;354    
                          ENDP

                  bsp_GetRunTime PROC
;;;362    */
;;;363    int32_t bsp_GetRunTime(void)
0001c6  2001              MOVS     r0,#1
0001c8  f3808810          MSR      PRIMASK,r0
;;;364    {
;;;365    	int32_t runtime;
;;;366    
;;;367    	DISABLE_INT();  	/* 关中断 */
;;;368    
;;;369    	runtime = g_iRunTime;	/* 这个变量在Systick中断中被改写，因此需要关中断进行保护 */
0001cc  4806              LDR      r0,|L1.488|
0001ce  6880              LDR      r0,[r0,#8]  ; g_iRunTime
;;;370    
;;;371    	ENABLE_INT();  		/* 开中断 */
0001d0  2100              MOVS     r1,#0
0001d2  f3818810          MSR      PRIMASK,r1
;;;372    
;;;373    	return runtime;
;;;374    }
0001d6  4770              BX       lr
;;;375    
                          ENDP

                  SysTick_Handler PROC
;;;383    */
;;;384    void SysTick_Handler(void)
0001d8  e7fe              B        SysTick_ISR
;;;385    {
;;;386    	SysTick_ISR();
;;;387    }
;;;388    
                          ENDP

0001da  0000              DCW      0x0000
                  |L1.476|
                          DCD      ||.bss||
                  |L1.480|
                          DCD      SystemCoreClock
                  |L1.484|
                          DCD      0xe000e00f
                  |L1.488|
                          DCD      ||.data||
                  |L1.492|
                          DCD      0x000f4240

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tTmr
                          %        48

                          AREA ||.data||, DATA, ALIGN=2

                  s_ucTimeOutFlag
000000  00                DCB      0x00
                  ms_count
000001  00                DCB      0x00
                  s_count
000002  0000              DCB      0x00,0x00
                  s_uiDelayCount
                          DCD      0x00000000
                  g_iRunTime
                          DCD      0x00000000
